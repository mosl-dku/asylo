# Google's Modifications to Intel's SGX Development Toolkit

## Top-level files added
  * `BUILD` to build with Bazel. Some targets use wrappers around `make` defined
    in `sgx_sdk.bzl`.
    - Changed `psw/ae/common/ProtobufSerializer` to work with a Bazel-controlled
      dependency instead of the system-installed `protobuf-compiler`.
  * `sgx_sdk.bzl` provides Skylark rules and macros to wrap `make` and provide
    tools to configure and sign enclave binaries with a debug test-only key.

## Directories added
### `include/`

Contains header files that are forwarded from the Intel SGX SDK to external
consumers. The files are needed by Asylo.

  * `global_data.h`: forwards `common/inc/internal/global_data.h` for use by
    the Asylo implementation of `sbrk`.
  * `sgx.h`: forwards `common/inc/sgx.h`
  * `sgx_edger8r.h`: forwards `common/inc/sgx_edger8r.h` for use by edger8r
    output targets.
  * `sgx_error.h`: forwards `common/inc/sgx_error.h` for SGXErrorSpace.
  * `sgx_lfence.h`: forwards `common/inc/sgx_lfence.h` for timing attack
    hardening that SGX Edger8r adds to boundary-crossing functions.
  * `sgx_thread.h`: forwards `common/inc/sgx_thread.h` for Asylo's threading
    support in SGX.
  * `sgx_trts.h`: forwards `common/inc/sgx_trts.h` for SGX trusted applications.
  * `sgx_trts_exception.h`: forwards `common/inc/sgx_trts_exception.h` for Asylo
    support of exception handlers.
  * `sgx_urts.h`: forwards `common/inc/sgx.h`

### `runtime_support/`

Contains headers, functions, and symbols needed by SGX SDK and PSW.

  * `rts_config.h` is for sources that need non standard C library functions,
     e.g., `memset_s`.
  * `sgx_init_string_lib.c` provides a new version of `sgx_init_string_lib`
    because we are using newlib instead of Intel's tlibc.
  * `sgx_init_crypto_lib.c` provides a new version of `sgx_init_crypto_lib`
    because we are using BoringSSL instead of Intel's tlibcrypto.


## Modifications to Intel's SDK
### Pending PRs
* [PR222](https://github.com/intel/linux-sgx/pull/222): Generate different code
  for user exception handlers in edger8r.
    - Affected files:
      + `sdk/edger8r/linux/Ast.ml`: Represent an exception handler function.
      + `sdk/edger8r/linux/CodeGen.ml`: Produce a new exception handler bit.
      + `sdk/edger8r/linux/Lexer.mll`: Add an exeception_handler token.
      + `sdk/edger8r/linux/Parser.mly`: Add exception_handler to function
        grammar and build a modified AST.
* [PR223](https://github.com/intel/linux-sgx/pull/223): Integrate with edger8r
  exception handler code to provide user handlers.
    - Affected files:
      + `trts_internal.h`
      + `trts_nsp.cpp`
* [PR316](https://github.com/intel/linux-sgx/pull/316): Allow enclaves to be
  created from buffers.
    - Affected files:
      + `common/inc/sgx_urts.h`
      + `psw/urts/enclave.cpp`
      + `psw/urts/urts_com.h`
      + `psw/urts/linux/urts.cpp`
    - The version in this patch differs slightly from the both the PR and the
      feature that Intel added in v2.4.
* [PR368](https://github.com/intel/linux-sgx/pull/368): Remove unused ill-
   defined "storage" field.
    - Affected files:
      + `common/inc/sgx_random_buffers.h`
* [PR450](https://github.com/intel/linux-sgx/pull/450): Add a missing #include
   for a necessary C-preprocessor define.
    - Affected files:
      + `sdk/trts/trts_veh.cpp`

### Non-upstreamed changes
* `sdk/trts/init_enclave.cpp`: Remove a memset_s of the enclave heap since
  Asylo does not support heap_init and sbrk in the manner needed for the cleared
  memory address to be meaningful. Without this, do_init_enclave segfaults.
* `external/rdrand/src/config.h`: Added the output of `./configure`
  since the build is ported entirely to Bazel.
* `sdk/trts/trts_nsp.cpp`: add "no-stack-protector" attribute to
  `init_stack_guard` to avoid resorting to the build system.
* `sdk/trts/trts_ecall.cpp` added
  `g_ecall_table.ecall_table[ordinal].is_exception` to the check condition of
  g_dyn_entry_table check to allow exception handler ecalls to pass even during
  an ocall of the interrupted frame. This deflakes our signal handling.
* Static stack size increase.
    - Affected files:
      + `sdk/trts/trts_internal.h`
      + `sdk/trts/linux/trts_pic.h`
      + `common/inc/internal/metadata.h`
    - *Changes:*
      + the first two headers change `STATIC_STACK_SIZE` from `8*100` to `8*1024`
        to avoid crash in the Asylo signal handler.
      + The third header changes `STACK_SIZE_MIN` from `0x1000` to `0x3000` to
        make sure it's larger than the static stack size.
    - *Detail:* `STATIC_STACK_SIZE` of stack is allocated for each tcs, and when
      an exception is raised, the frame that enters enclave to deal with the
      exception shares the same tcs as the enclave frame being interrupted,
      hence uses the memory directly adjacent. It will overwrite the interrupted
      frame's stack when it overflows. Since the exception handler makes a few
      functions calls to enter enclave to handle the exception, when combined
      with the use of STL containers it's easy to exceed the original stack
      size.
* `sdk/trts/linux/x86_64/setcontext.S` stubs out `ucontext` and
  `__NR_rt_sigprocmask` since we don't have it working yet.
* `psw/ae/common/proto/messages.proto` add syntax statement.
* `psw/ae/common/src/ProtobufSerializer.h` remove unnecessary include of
  protobuf's message.h.
* `sdk/trts/trts_ecall.cpp` added `interrupted` as an argument to
  `do_ecall`, and only initialize thread data if it is false.
* `sdk/trts/trts_internal.h` added `interrupted` as an argument to
  `do_ecall`.
* `sdk/trts/trts.cpp` pass `interrupted` argument to `do_ecall`. If
  `cssa` is 0, `interrupted` is false, otherwise it's true.
* `psw/urts/linux/sig_handler.cpp` remove registering sgx signal
  handlers for SIGSEGV, SIGFPE, SIGBUS, and SIGTRAP.
* Allow enclaves to be created at specified address.
  `common/inc/sgx_urts.h`, `psw/urts/linux/urts.cpp` added
  `SGX_CREATE_ENCLAVE_EX_ASYLO` for `ex_features` to carry Asylo-specific enclave-
  features.
  `psw/urts/urts_com.h` passes some Asylo creation data along to
  `CLoader::load_enclave_ex`.
  `psw/urts/loader.h`, `psw/urts/loader.cpp` added
  `enclave_base_addr` as an argument to `load_enclave_ex`, `load_enclave`,
  `build_image`, `build_secs`, and pass it down. In `build_secs`, set
  `m_start_addr` to `enclave_base_addr` before calling EnclaveCreator, and set
  `enclave_base_addr` to the returned `m_start_addr` after enclave is created.
  `psw/urts/linux/enclave_creator_hw.cpp` change the default mmap
  address from `NULL` to `start_addr` to allow creating enclave at specified
  address in `EnclaveCreatorHW::create_enclave`.
  `sdk/simulation/driver_api/driver_api.cpp` initialize `pinfo.lin_addr`
  to `start_addr` in `create_enclave`.
  `sdk/simulation/uinst/u_instructions.cpp` change `se_virtual_alloc`
  address for `NULL` to `pi->lin_addr` in `_ECREATE`.
  `psw/enclave_common/sgx_enclave_common.cpp` add a static `pid`, and
  check the pid everytime when checking `s_enclave_init` table. If `pid` has
  changed, clear `s_enclave_int` table.
* Add a utility specifier to edger8r.
  `sdk/edger8r/linux/Ast.ml` add tf_is_utility field to trusted_func.
  `sdk/edger8r/linux/CodeGen.ml` add is_utility_ecall check, add
  tf_list_to_utility_list method, fold it into ecall table in `gen_ecall_table`,
  check the value in `gen_func_uproxy` and add this as a new parameter to
  `sgx_ecall`, add check to `check_priv_funcs` to check for at least one
  non-private and non-utility ecall.
  `sdk/edger8r/linux/Lexer.mll` add Tutility to the parse rule.
  `sdk/edger8r/linux/Parser.mly` add Tutility to token, add utility check
  in trusted_functions parser.
  `common/inc/sgx_edger8r.h`, `common/inc/internal/routine.h`,
  `psw/urts/routine.cpp` add a new bool variable `is_utility` to
  `sgx_ecall`.
* Reserve `user_utility_thread` and make `utility` ecalls to use this tcs.
  `common/inc/internal/rts_cmd.h` add a `ECMD_UTILITY` macro.
  `psw/urts/enclave.cpp` in `CEnclave::ecall`, check `is_utility`
  parameter, if it's true, pass `ECMD_UTILITY` to `get_tcs`. And pass
  `is_utility` as `false` to `ecall` in `init_uswitchless`.
  `psw/urts/enclave_creator_hw_com.cpp` pass `is_utility` as `false` to
  `enclave->ecall` in `EnclaveCreatorHW::initialize`.
  `psw/urts/routine.cpp` pass `is_utility` to `enclave->ecall` in
  `_sgx_ecall`.
  `psw/urts/tcs.h` add `CTrustThread *m_user_utility_thread` as a private
  member of `CTrustThreadPool`.
  `psw/urts/tcs.cpp` initialize `m_user_utility_thread` as `NULL` in the
  constructor of `CTrustThreadPool`, and delete it in the destructor. set
  `m_user_utility_thread` to `trust_thread` after setting `m_utility_thread` in
  `CTrustThreadPool::add_thread`. add condition `&& m_user_utility_thread !=
  NULL` to `CTrustThreadPool::_acquire_thread`. check `ecall_cmd` in
  `CTrustThreadPool::acquire_thread`, if it's `ECMD_UTILITY`, assign
  `m_utility_thread` to `trust_thread`.
  `psw/urts/urts_com.h` pass `is_utility` as `false` to `enclave->ecall`
  in `sgx_destroy_enclave`.
  `psw/urts/linux_sig_handler.cpp` pass `is_utility` as `false` to
  `enclave->ecall` in `sig_handler`.
  `sdk/simulation/urtssim/enclave_creator_sim.cpp` pass `is_utility` as
  `false` to `enclave->ecall` in `EnclaveCreatorSim::initialize`.
  `sdk/trts/trts_ecall.cpp` allow ecall if it's utility even if it's the
  first ecall of the tcs and is prviate in `is_ecall_allowed`.
  `sdk/trts/trts_internal.h` add `uint8_t is_utility` to `struct
  ecall_addr_t`.
* Provide SGXAPI to expose enclave data/bss/stack/heap/thread address and size.
  `common/inc/sgx_trts.h` add a struct `MemoryLayout` that includes
  address and size for data, bss, heap, thread, and stack, also add a
  `sgx_memory_layout(struct MemoryLayout *memory_layout)` API.
  `common/inc/internal/global_data.h` add `sys_word_t` fields
  `data_offset`, `data_size`, `bss_offset`, `bss_size` to `struct
  global_data_t`.
  `psw/urts/parser/elfparser.cpp` in `update_global_data`, read the
  section of `ELF_DATA` and `ELF_BSS`, save the corresponding address and size
  to `data`.
  `sdk/trts/init_enclave.cpp` add the 4 new fields initialization to
  `g_global_data`.
  `sdk/trts/trts.cpp` include `trts_util.h` header, and provide
  implementation for `sgx_memory_layout` by calling `get_memory_layout`.
  `sdk/trts/trts_util.h` provide declaration of `get_memory_layout`.
  `sdk/trts/trts_util.h` provide implementation for `get_memory_layout` by
  getting the address and size of data/bss/heap from `global_data`, and get
  thread and stack from `thread_data`.
  `sdk/selib/sgx_create_report.cpp` replace use of custom tlibc `__memset` with
  `memset`.
  `sdk/tlibc/gen/spinlock.c` rename `_mm_pause` to `alt_mm_pause` to avoid
  errors around redefining builtin functions.
  `sdk/trts/trts_nsp.cpp` move `init_stack_guard` into its own library
  `trts_nsp_internal` to allow for `-fno-stack-protector` to apply to just the
  one function for compilers that don't support
  `__attribute__((optimize(...)))`.
* Add support for accessing thread local storage (TLS) when registering
  signal handlers in `sdk/simulation/uinst/u_instructions.cpp`.
* Mask signals in SGX simulation mode while entering the enclave in "SE3" to
  avoid signal handling accessing wrong TLS in
  `sdk/simulation/uinst/u_instructions.cpp`.
* Change the order to first set tcs state and then restore TLS in simulation
  mode while exiting the enclave in "SE3" to avoid rejected entry of signal
  handler if a signal arrives in the window between restoring TLS and setting
  tcs state in `sdk/simulation/tinst/t_instructions.cpp`.
--
diff -Nur common/inc/internal/elfheader/elf_common.h common/inc/internal/elfheader/elf_common.h
--- common/inc/internal/elfheader/elf_common.h
+++ common/inc/internal/elfheader/elf_common.h
@@ -30,6 +30,9 @@
 #ifndef _SYS_ELF_COMMON_H_
 #define	_SYS_ELF_COMMON_H_ 1
 
+#include <stddef.h>
+#include <stdint.h>
+
 typedef uint32_t u_int32_t;
 typedef uint32_t Elf_Symndx;
 
diff -Nur common/inc/internal/elfheader/elfstructs.h common/inc/internal/elfheader/elfstructs.h
--- common/inc/internal/elfheader/elfstructs.h
+++ common/inc/internal/elfheader/elfstructs.h
@@ -26,6 +26,9 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include <stddef.h>
+#include <stdint.h>
+
 typedef uint8_t		Elf_Byte;
 
 typedef uint32_t	Elf32_Addr;	/* Unsigned program address */
diff -Nur common/inc/internal/global_data.h common/inc/internal/global_data.h
--- common/inc/internal/global_data.h
+++ common/inc/internal/global_data.h
@@ -50,6 +50,10 @@
     sys_word_t     enclave_size;
     sys_word_t     heap_offset;
     sys_word_t     heap_size;
+    sys_word_t     data_offset;
+    sys_word_t     data_size;
+    sys_word_t     bss_offset;
+    sys_word_t     bss_size;
     sys_word_t     rsrv_offset;
     sys_word_t     rsrv_size;
     sys_word_t     thread_policy;
diff -Nur common/inc/internal/metadata.h common/inc/internal/metadata.h
--- common/inc/internal/metadata.h
+++ common/inc/internal/metadata.h
@@ -72,7 +72,7 @@
 #define SSA_NUM_MIN         2
 #define SSA_FRAME_SIZE_MIN  1
 #define SSA_FRAME_SIZE_MAX  2
-#define STACK_SIZE_MIN      0x0002000 /*   8 KB */
+#define STACK_SIZE_MIN      0x0003000 /*   12 KB */
 #define STACK_SIZE_MAX      0x0040000 /* 256 KB */
 #define HEAP_SIZE_MIN       0x0001000 /*   4 KB */
 #define HEAP_SIZE_MAX       0x1000000 /*  16 MB */
diff -Nur common/inc/internal/pcl_common.h common/inc/internal/pcl_common.h
--- common/inc/internal/pcl_common.h
+++ common/inc/internal/pcl_common.h
@@ -32,6 +32,10 @@
 #ifndef PCL_COMMON_H
 #define PCL_COMMON_H
 
+#include <stddef.h>
+#include <stdint.h>
+#include "sgx_tcrypto.h"
+
 /*
  * This file includes definition used by PCL library and encryption tool
  */
diff -Nur common/inc/internal/routine.h common/inc/internal/routine.h
--- common/inc/internal/routine.h
+++ common/inc/internal/routine.h
@@ -36,6 +36,8 @@
 #include "sgx_error.h"
 #include "sgx_defs.h"
 
+#include <stdbool.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -46,7 +48,7 @@
     void *ocall[];
 } sgx_ocall_table_t;
 
-sgx_status_t SGXAPI sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms);
+sgx_status_t SGXAPI sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility);
 
 #ifdef __cplusplus
 }
diff -Nur common/inc/internal/rts_cmd.h common/inc/internal/rts_cmd.h
--- common/inc/internal/rts_cmd.h
+++ common/inc/internal/rts_cmd.h
@@ -36,10 +36,12 @@
 #define ECMD_EXCEPT         -3
 #define ECMD_MKTCS          -4
 #define ECMD_UNINIT_ENCLAVE -5
+#define ECMD_UTILITY        -6
+#define ECMD_UTILITY_EXCEPT -7
 
 /* Built-in ECall command for Switchless SGX */
-#define ECMD_INIT_SWITCHLESS         (-6)
-#define ECMD_RUN_SWITCHLESS_TWORKER  (-7)
+#define ECMD_INIT_SWITCHLESS         (-8)
+#define ECMD_RUN_SWITCHLESS_TWORKER  (-9)
 
 /* OCALL command */
 #define OCMD_ERET         -1
diff -Nur common/inc/internal/se_tcrypto_common.h common/inc/internal/se_tcrypto_common.h
--- common/inc/internal/se_tcrypto_common.h
+++ common/inc/internal/se_tcrypto_common.h
@@ -33,6 +33,11 @@
 #ifndef _SE_TCRYPTO_COMMON_H_
 #define _SE_TCRYPTO_COMMON_H_
 
+#include <limits.h>
+#include "openssl/bn.h"
+#include "openssl/ecdsa.h"
+#include "runtime_support/rts_config.h"
+
 #ifdef USE_SGXSSL
 
 
diff -Nur common/inc/internal/sgx_read_rand.h common/inc/internal/sgx_read_rand.h
--- common/inc/internal/sgx_read_rand.h
+++ common/inc/internal/sgx_read_rand.h
@@ -31,6 +31,8 @@
 
 #ifndef __SGX_READ_RAND_H__
 #define __SGX_READ_RAND_H__
+#include <stddef.h>
+#include <stdint.h>
 #include "sgx.h"
 #include "sgx_defs.h"
 #ifdef __cplusplus
diff -Nur common/inc/internal/sl_workers.h common/inc/internal/sl_workers.h
--- common/inc/internal/sl_workers.h
+++ common/inc/internal/sl_workers.h
@@ -70,7 +70,7 @@
 #ifndef SL_INSIDE_ENCLAVE /* Untrusted */
     pthread_t*                          threads;
 #else /* Trusted */
-    void*                               __unused;
+    void*                               field_is_unused;
 #endif /* SL_INSIDE_ENCLAVE */
 };
 
diff -Nur common/inc/internal/trts_inst.h common/inc/internal/trts_inst.h
--- common/inc/internal/trts_inst.h
+++ common/inc/internal/trts_inst.h
@@ -68,6 +68,7 @@
 int sgx_accept_forward(si_flags_t sfl, size_t lo, size_t hi);
 int do_ereport(const sgx_target_info_t *target_info, const sgx_report_data_t *report_data, sgx_report_t *report);
 int do_egetkey(const sgx_key_request_t *key_request, sgx_key_128bit_t *key);
+sgx_status_t egetkey_status_to_sgx_status(int egetkey_status);
 uint32_t do_rdrand(uint32_t *rand);
 int do_eaccept(const sec_info_t *, size_t);
 int do_emodpe(const sec_info_t*, size_t);
diff -Nur common/inc/sgx_edger8r.h common/inc/sgx_edger8r.h
--- common/inc/sgx_edger8r.h
+++ common/inc/sgx_edger8r.h
@@ -43,6 +43,7 @@
 #ifndef _SGX_EDGER8R_H_
 #define _SGX_EDGER8R_H_
 
+#include <stdbool.h>
 #include "sgx_defs.h"
 #include "sgx_error.h"
 #include "sgx_eid.h"
@@ -90,11 +91,13 @@
 sgx_status_t SGXAPI sgx_ecall(const sgx_enclave_id_t eid,
                               const int index,
                               const void* ocall_table,
-                              void* ms);
+                              void* ms,
+                              bool is_utility);
 sgx_status_t SGXAPI sgx_ecall_switchless(const sgx_enclave_id_t eid,
                               const int index,
                               const void* ocall_table,
-                              void* ms);
+                              void* ms,
+                              bool is_utility);
 
 /* sgx_ocall()
  * Parameters:
diff -Nur common/inc/sgx_pcl_guid.h common/inc/sgx_pcl_guid.h
--- common/inc/sgx_pcl_guid.h
+++ common/inc/sgx_pcl_guid.h
@@ -31,6 +31,9 @@
 
 #ifndef SGX_PCL_GUID_H
 #define SGX_PCL_GUID_H
+
+#include <stdint.h>
+
 /*
  * GUID enables coupling of PCL lib (e.g. libsgx_pcl.a) and sealed blob
  * Before the PCL unseals the sealed blob, the PCL must verify the AAD 
diff -Nur common/inc/sgx_random_buffers.h common/inc/sgx_random_buffers.h
--- common/inc/sgx_random_buffers.h
+++ common/inc/sgx_random_buffers.h
@@ -36,6 +36,11 @@
 #   error This header needs c++11 or later
 #endif
 
+#ifdef SE_SIM
+#include <stdint.h>
+#include <limits>
+#include <random>
+#endif
 #include <utility>
 #include <string.h>
 #include <stdlib.h>
@@ -43,6 +48,37 @@
 
 extern int EDMM_supported;
 
+#ifdef SE_SIM
+class InsecureRandomGenerator {
+ public:
+  using result_type = unsigned;
+
+  result_type operator()() {
+    return rand_r(&seed_);
+  }
+
+  static constexpr result_type min() {
+    return std::numeric_limits<result_type>::min();
+  }
+
+  static constexpr result_type max() {
+    return std::numeric_limits<result_type>::max();
+  }
+
+ private:
+  // Avoid a system call like time() since this may be used before system calls
+  // are available.
+  unsigned seed_ = static_cast<unsigned>(reinterpret_cast<uintptr_t>(this));
+};
+
+template <class R = unsigned>
+R insecure_rand(void) {
+  thread_local InsecureRandomGenerator generator;
+  std::uniform_int_distribution<R> dist;
+  return dist(generator);
+}
+#endif
+
 /*
  * This function is equivalent to __builtin_rdrand16/32/64_step() except it
  * returns the random value instead of writing it to memory, which is required
@@ -51,9 +87,13 @@
 template <class R = unsigned>
 inline R rdrand(void)
 {
+#ifndef SE_SIM
     R r;
     __asm__ volatile ("rdrand %0" : "=r"(r));
     return r;
+#else
+    return insecure_rand<R>();
+#endif
 }
 
 /*
@@ -129,7 +169,8 @@
 template <class T, std::size_t A, unsigned M = 0x1000>
 struct alignas(A)randomly_placed_buffer
 {
-    static constexpr std::size_t size(std::size_t count = 1)
+    static constexpr std::size_t default_size_count = 1;
+    static constexpr std::size_t size(std::size_t count = default_size_count)
     {
         //
         // gives error with gcc 4.8
@@ -274,7 +315,7 @@
         }
     };
 
-    char __bigger_[size()];
+    char __bigger_[size(default_size_count)];
 };
 
 template <class T, unsigned M = 0x1000>
diff -Nur common/inc/sgx_trts.h common/inc/sgx_trts.h
--- common/inc/sgx_trts.h
+++ common/inc/sgx_trts.h
@@ -35,6 +35,7 @@
 #include "sgx_error.h"
 #include "stddef.h"
 #include "sgx_defs.h"
+#include "runtime_support/rts_config.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -82,6 +83,77 @@
 */
 sgx_status_t SGXAPI sgx_read_rand(unsigned char *rand, size_t length_in_bytes);
 
+struct SgxMemoryLayout {
+  // Enclave load address.
+  void *base;
+  // Size of the enclave in bytes.
+  size_t size;
+  // Base address of the initialized data section in the current enclave.
+  void *data_base;
+  // Size of the initialized data section in the current enclave.
+  size_t data_size;
+  // Base address of the uninitialized data section in the current enclave.
+  void *bss_base;
+  // Size of the uninitialized data section in the current enclave.
+  size_t bss_size;
+  // Base address of heap in the current enclave.
+  void *heap_base;
+  // size of heap in the current enclave.
+  size_t heap_size;
+  // Base address of the thread data for the current tcs.
+  void *thread_base;
+  // Size of the thread data for the current tcs.
+  size_t thread_size;
+  // Base address of the stack for the current tcs.
+  void *stack_base;
+  // Limit address of the stack for the current tcs.
+  void *stack_limit;
+  // Base address of the reserved data storage section.
+  void *reserved_data_base;
+  // Size of the reserved data storage section.
+  size_t reserved_data_size;
+  // Base address of the reserved bss storage section.
+  void *reserved_bss_base;
+  // Size of the reserved bss storage section.
+  size_t reserved_bss_size;
+  // Base address of the reserved heap storage section.
+  void *reserved_heap_base;
+  // Size of the reserved heap storage section.
+  size_t reserved_heap_size;
+};
+
+/* sgx_memory_layout()
+ * Parameters:
+ *      memory_layout - Receives the memory layout of the current enclave
+ *      (data/bss/heap) and for current tcs(thread data/stack).
+ */
+void SGXAPI sgx_memory_layout(struct SgxMemoryLayout *memory_layout);
+
+/* sgx_get_active_enclave_entries()
+ * Return Value - the number of active entries inside the enclave.
+ */
+int SGXAPI sgx_active_entry_count();
+
+/* sgx_block_entries()
+ * Block all entries into the enclave.
+ */
+void SGXAPI sgx_block_entries();
+
+/* sgx_unblock_entries()
+ * Unblock entries into the enclave.
+ */
+void SGXAPI sgx_unblock_entries();
+
+/* sgx_blocked_entry_count()
+ * Return Value - tne number of entries blocked from reentering the enclave.
+ */
+int SGXAPI sgx_blocked_entry_count();
+
+/* sgx_reject_entries()
+ * Rejects all entries into the enclave.
+ */
+void SGXAPI sgx_reject_entries();
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur common/inc/sgx_urts.h common/inc/sgx_urts.h
--- common/inc/sgx_urts.h
+++ common/inc/sgx_urts.h
@@ -34,6 +34,8 @@
 #ifndef _SGX_URTS_H_
 #define _SGX_URTS_H_
 
+#include <stddef.h>
+
 #include "sgx_attributes.h"
 #include "sgx_error.h"
 #include "sgx_eid.h"
@@ -54,6 +56,8 @@
 
 #define SGX_CREATE_ENCLAVE_EX_KSS_BIT_IDX           2U
 #define SGX_CREATE_ENCLAVE_EX_KSS                  (1U << SGX_CREATE_ENCLAVE_EX_KSS_BIT_IDX)  // Bit 2 for Key Separation & Sharing 
+#define SGX_CREATE_ENCLAVE_EX_ASYLO_BIT_IDX  3U
+#define SGX_CREATE_ENCLAVE_EX_ASYLO         (1U << SGX_CREATE_ENCLAVE_EX_ASYLO_BIT_IDX)  // Bit 3 for Asylo extensions
 
 #pragma pack(push, 1)
 
@@ -64,11 +68,17 @@
     sgx_config_svn_t config_svn;
 } sgx_kss_config_t;
 
+typedef struct _asylo_sgx_config_t {
+  void **base_address;
+  size_t enclave_size;
+  bool enable_user_utility;
+} asylo_sgx_config_t;
+
 #pragma pack(pop)
 
 
 //update the following when adding new extended feature
-#define _SGX_LAST_EX_FEATURE_IDX_  SGX_CREATE_ENCLAVE_EX_KSS_BIT_IDX 
+#define _SGX_LAST_EX_FEATURE_IDX_  SGX_CREATE_ENCLAVE_EX_ASYLO_BIT_IDX 
 
 #define _SGX_EX_FEATURES_MASK_ (((uint32_t)-1) >> (MAX_EX_FEATURES_COUNT - 1  - _SGX_LAST_EX_FEATURE_IDX_))
 
@@ -132,6 +142,10 @@
 	const sgx_enclave_id_t enclave_id,
 	sgx_target_info_t* target_info);
 
+void SGXAPI sgx_set_process_id(const sgx_enclave_id_t enclave_id);
+
+size_t SGXAPI sgx_enclave_size(const sgx_enclave_id_t enclave_id);
+
 #ifdef __cplusplus
 }
 #endif
diff -Nur common/inc/tlibc/string.h common/inc/tlibc/string.h
--- common/inc/tlibc/string.h
+++ common/inc/tlibc/string.h
@@ -79,7 +79,8 @@
 char * _TLIBC_CDECL_ strtok(char *, const char *);
 size_t _TLIBC_CDECL_ strxfrm(char *, const char *, size_t);
 size_t _TLIBC_CDECL_ strlcpy(char *, const char *, size_t);
-errno_t _TLIBC_CDECL_ memset_s(void *s, size_t smax, int c, size_t n);
+// Declared in rts_config.h
+// errno_t _TLIBC_CDECL_ memset_s(void *s, size_t smax, int c, size_t n);
 
 /*
  * Deprecated C99.
@@ -92,7 +93,9 @@
  */
 char * _TLIBC_CDECL_ strndup(const char *, size_t);
 size_t _TLIBC_CDECL_ strnlen(const char *, size_t);
-int    _TLIBC_CDECL_ consttime_memequal(const void *b1, const void *b2, size_t len);
+// Declared in rts_config.h
+// int    _TLIBC_CDECL_ consttime_memequal(const void *b1, const void *b2,
+// size_t len);
 
 /*
  * Non-C99
diff -Nur common/src/linux/xsave_gnu.S common/src/linux/xsave_gnu.S
--- common/src/linux/xsave_gnu.S
+++ common/src/linux/xsave_gnu.S
@@ -34,6 +34,8 @@
 
 #include "linux/linux-regs.h"
 
+.section        .note.GNU-stack, "", %progbits
+
 .macro DO_XSAVEC
 #if defined(LINUX64)
     .byte   0x48, 0x0f, 0xc7, 0x21
diff -Nur common/src/se_rwlock.c common/src/se_rwlock.c
--- common/src/se_rwlock.c
+++ common/src/se_rwlock.c
@@ -33,37 +33,53 @@
 #include "se_rwlock.h"
 #include "internal/util.h"
 
-
+#include <signal.h>
 #include <stdlib.h>
+
+// Mask all the signals while acquiring/releasing the lock. Because signal
+// handler acquires the lock as well. It could cause deadlock/crash if the lock
+// is being acquired/released when interrupted. Recursive/read lock does not
+// prevent it.
+int mask_signals_and_run(int (*func)(se_prwlock_t), se_prwlock_t lock)
+{
+    sigset_t mask;
+    sigfillset(&mask);
+    sigset_t old_mask;
+    sigprocmask(SIG_SETMASK, &mask, &old_mask);
+    int ret = func(lock);
+    sigprocmask(SIG_SETMASK, &old_mask, NULL);
+    return ret;
+}
+
 void se_wtlock(se_prwlock_t lock)
 {
-    int ret = pthread_rwlock_wrlock(lock);
+    int ret = mask_signals_and_run(pthread_rwlock_wrlock, lock);
     if(0 != ret)
         abort();
 }
 
 void se_wtunlock(se_prwlock_t lock)
 {
-    int ret = pthread_rwlock_unlock(lock);
+    int ret = mask_signals_and_run(pthread_rwlock_unlock, lock);
     if(0 != ret)
         abort();
 }
 
 int se_try_rdlock(se_prwlock_t lock)
 {
-    return (0 == pthread_rwlock_tryrdlock(lock));
+    return (0 == mask_signals_and_run(pthread_rwlock_tryrdlock, lock));
 }
 
 void se_rdlock(se_prwlock_t lock)
 {
-    int ret = pthread_rwlock_rdlock(lock);
+    int ret = mask_signals_and_run(pthread_rwlock_rdlock, lock);
     if(0 != ret)
         abort();
 }
 
 void se_rdunlock(se_prwlock_t lock)
 {
-    int ret = pthread_rwlock_unlock(lock);
+    int ret = mask_signals_and_run(pthread_rwlock_unlock, lock);
     if(0 != ret)
         abort();
 }
diff -Nur common/src/sgx_read_rand.cpp common/src/sgx_read_rand.cpp
--- common/src/sgx_read_rand.cpp
+++ common/src/sgx_read_rand.cpp
@@ -38,7 +38,9 @@
 #include "sgx.h"
 #include "sgx_defs.h"
 #include "se_wrapper.h"
-#include "rdrand.h"
+extern "C" {
+#include "rdrand.h"
+}
 #include "cpuid.h"
 #include <stdio.h>
 #ifndef UINT32_MAX
diff -Nur psw/ae/aesm_service/source/bundles/ecdsa_quote_service_bundle/ecdsa_quote_service_bundle.cpp psw/ae/aesm_service/source/bundles/ecdsa_quote_service_bundle/ecdsa_quote_service_bundle.cpp
--- psw/ae/aesm_service/source/bundles/ecdsa_quote_service_bundle/ecdsa_quote_service_bundle.cpp
+++ psw/ae/aesm_service/source/bundles/ecdsa_quote_service_bundle/ecdsa_quote_service_bundle.cpp
@@ -1,19 +1,13 @@
 #include <quote_provider_service.h>
 #include <pce_service.h>
 
-#include <cppmicroservices/BundleActivator.h>
-#include "cppmicroservices/BundleContext.h"
-#include <cppmicroservices/GetBundleContext.h>
-
 #include <iostream>
+#include <memory>
 #include "aesm_logic.h"
 #include "sgx_quote_3.h"
 #include "sgx_ql_quote.h"
 #include "sgx_ql_core_wrapper.h"
 
-#include "cppmicroservices_util.h"
-
-using namespace cppmicroservices;
 std::shared_ptr<IPceService> g_pce_service;
 static AESMLogicMutex ecdsa_quote_mutex;
 extern const sgx_ql_att_key_id_t g_default_ecdsa_p256_att_key_id;
@@ -207,6 +201,7 @@
                                   sgx_misc_attribute_t *p_qe_attributes,
                                   sgx_launch_token_t *p_launch_token);
 
+#if 0
 class EcdsaQuoteServiceImp : public IQuoteProviderService
 {
 private:
@@ -383,3 +378,5 @@
 #ifdef NO_CMAKE
 CPPMICROSERVICES_INITIALIZE_BUNDLE(ecdsa_quote_service_bundle_name)
 #endif
+
+#endif
diff -Nur psw/ae/aesm_service/source/core/ipc/IAEMessage.h psw/ae/aesm_service/source/core/ipc/IAEMessage.h
--- psw/ae/aesm_service/source/core/ipc/IAEMessage.h
+++ psw/ae/aesm_service/source/core/ipc/IAEMessage.h
@@ -37,7 +37,7 @@
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wshadow"
 #pragma GCC diagnostic ignored "-Wconversion"
-#include "messages.pb.h"
+#include "psw/ae/aesm_service/source/core/ipc/messages.pb.h"
 #pragma GCC diagnostic pop
 
 struct AEMessage{
diff -Nur psw/ae/aesm_service/source/core/ipc/IAESMLogic.h psw/ae/aesm_service/source/core/ipc/IAESMLogic.h
--- psw/ae/aesm_service/source/core/ipc/IAESMLogic.h
+++ psw/ae/aesm_service/source/core/ipc/IAESMLogic.h
@@ -31,6 +31,7 @@
 #ifndef _I_AESM_LOGIC_H
 #define _I_AESM_LOGIC_H
 
+#include <stddef.h>
 #include <stdint.h>
 #include <aeerror.h>
 #include <aesm_error.h>
diff -Nur psw/ae/aesm_service/source/core/ipc/ProtobufSerializer.cpp psw/ae/aesm_service/source/core/ipc/ProtobufSerializer.cpp
--- psw/ae/aesm_service/source/core/ipc/ProtobufSerializer.cpp
+++ psw/ae/aesm_service/source/core/ipc/ProtobufSerializer.cpp
@@ -34,7 +34,6 @@
  */
 
 #include <ProtobufSerializer.h>
-#include <google/protobuf/message.h>
 #include <IAEMessage.h>
 
 #include <IAERequest.h>
diff -Nur psw/ae/aesm_service/source/interfaces/get_att_key_id.h psw/ae/aesm_service/source/interfaces/get_att_key_id.h
--- psw/ae/aesm_service/source/interfaces/get_att_key_id.h
+++ psw/ae/aesm_service/source/interfaces/get_att_key_id.h
@@ -1,5 +1,8 @@
 #ifndef GET_ATT_KEY_ID_H
 #define GET_ATT_KEY_ID_H
+
+#include <stdint.h>
+
 #include "aesm_error.h"
 
 struct IGetAttKeyID
diff -Nur psw/ae/inc/internal/pse_inc.h psw/ae/inc/internal/pse_inc.h
--- psw/ae/inc/internal/pse_inc.h
+++ psw/ae/inc/internal/pse_inc.h
@@ -35,7 +35,6 @@
 
 #include "se_cdefs.h"
 #include "sgx_utils.h"
-#include "sgx_trts.h"
 #include "string.h"
 #include "aeerror.h"
 
diff -Nur psw/enclave_common/sgx_enclave_common.cpp psw/enclave_common/sgx_enclave_common.cpp
--- psw/enclave_common/sgx_enclave_common.cpp
+++ psw/enclave_common/sgx_enclave_common.cpp
@@ -43,12 +43,14 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/types.h>
+#include <unistd.h>
 
 #define POINTER_TO_U64(A) ((__u64)((uintptr_t)(A)))
 
 static se_file_handle_t s_hdevice = -1;
 static bool s_is_kernel_driver = false;
 static se_mutex_t s_device_mutex;
+static pid_t s_pid = -1;
 
 static std::map<void*, size_t> s_enclave_size;
 static std::map<void*, bool> s_enclave_init;
@@ -63,7 +65,7 @@
 
 static std::map<void*, mem_region_t> s_enclave_mem_region;
 
-extern "C" bool open_device(void)
+static bool open_device(void)
 {
     se_mutex_lock(&s_device_mutex);
     if (s_hdevice != -1) {
@@ -83,7 +85,7 @@
     return false;
 }
 
-extern "C" void close_device(void)
+static void close_device(void)
 {
     se_mutex_lock(&s_device_mutex);
 
@@ -225,7 +227,15 @@
         return NULL;
     }
 
-    void* enclave_base = mmap(base_address, virtual_size, PROT_NONE, MAP_SHARED, s_hdevice, 0);
+    // If enclave is to be created at a specified address, release that memory
+    // and fix the mapping space.
+    int flag = MAP_SHARED;
+    if (base_address)
+    {
+        munmap(base_address, virtual_size);
+        flag |= MAP_FIXED;
+    }
+    void* enclave_base = mmap(base_address, virtual_size, PROT_NONE, flag, s_hdevice, 0);
     if (enclave_base == MAP_FAILED) {
         SE_TRACE(SE_TRACE_WARNING, "\ncreate enclave: mmap failed, errno = %d\n", errno);
         if (enclave_error != NULL)
@@ -496,6 +506,13 @@
     }
 
     se_mutex_lock(&s_enclave_mutex);
+    // If the process ID has changed, |s_enclave_init| is inherited from a
+    // parent process. The enclaves are not going to be copied, so clear the
+    // table.
+    if (s_pid != -1 && s_pid != getpid()) {
+      s_enclave_init.clear();
+    }
+    s_pid = getpid();
     std::map<void*, bool>::iterator it = s_enclave_init.find(base_address);
     if (it != s_enclave_init.end() && it->second) {
         se_mutex_unlock(&s_enclave_mutex);
diff -Nur psw/urts/cpu_features.cpp psw/urts/cpu_features.cpp
--- psw/urts/cpu_features.cpp
+++ psw/urts/cpu_features.cpp
@@ -76,17 +76,18 @@
     unsigned int cpuid7_eax, cpuid7_ebx, cpuid7_ecx, cpuid7_edx;
     unsigned int ecpuid1_eax, ecpuid1_ebx, ecpuid1_ecx, ecpuid1_edx;
     uint64_t cpu_feature_indicator = CPU_FEATURE_GENERIC_IA32;
+    bool is_intel;
 
     sgx_cpuid(0, &cpuid0_eax, &cpuid0_ebx, &cpuid0_ecx, &cpuid0_edx);
-    if(cpuid0_eax == 0 ||
-            !(cpuid0_ebx == CPU_GENU_VAL &&
-              cpuid0_edx == CPU_INEI_VAL &&
-              cpuid0_ecx == CPU_NTEL_VAL))
+    if(cpuid0_eax == 0)
     {
         *__intel_cpu_feature_indicator = cpu_feature_indicator;
         return;
     }
 
+    is_intel = (cpuid0_ebx == CPU_GENU_VAL && cpuid0_edx == CPU_INEI_VAL &&
+                cpuid0_ecx == CPU_NTEL_VAL);
+
     sgx_cpuid(1, &cpuid1_eax, &cpuid1_ebx, &cpuid1_ecx, &cpuid1_edx);
     if (CPU_MODEL(cpuid1_eax) == CPU_ATOM1 ||
             CPU_MODEL(cpuid1_eax) == CPU_ATOM2 ||
@@ -162,16 +163,16 @@
     if (CPU_HAS_BMI(cpuid7_ebx)) {
         cpu_feature_indicator |= CPU_FEATURE_BMI;
     }
-    if (CPU_HAS_LZCNT(ecpuid1_ecx)) {
+    if (is_intel && CPU_HAS_LZCNT(ecpuid1_ecx)) {
         cpu_feature_indicator |= CPU_FEATURE_LZCNT;
     }
     if (CPU_HAS_PREFETCHW(ecpuid1_ecx)) {
         cpu_feature_indicator |= CPU_FEATURE_PREFETCHW;
     }
-    if (CPU_HAS_HLE(cpuid7_ebx)) {
+    if (is_intel && CPU_HAS_HLE(cpuid7_ebx)) {
         cpu_feature_indicator |= CPU_FEATURE_HLE;
     }
-    if (CPU_HAS_RTM(cpuid7_ebx)) {
+    if (is_intel && CPU_HAS_RTM(cpuid7_ebx)) {
         cpu_feature_indicator |= CPU_FEATURE_RTM;
     }
     if (CPU_HAS_RDSEED(cpuid7_ebx)) {
diff -Nur psw/urts/cpu_features_ext.cpp psw/urts/cpu_features_ext.cpp
--- psw/urts/cpu_features_ext.cpp
+++ psw/urts/cpu_features_ext.cpp
@@ -63,20 +63,22 @@
     bool ecpuid14_initialized = false;
     uint64_t xfeature_mask = 0;
     bool xfeature_initialized = false;
+    bool is_intel = false;
     FeatureId curr_feature;
 
 	uint64_t cpu_feature_indicator = get_bit_from_feature_id(c_feature_generic_ia32);
 
 	sgx_cpuid(0, &cpuid0_eax, &cpuid0_ebx, &cpuid0_ecx, &cpuid0_edx);
-	if (cpuid0_eax == 0 ||
-		!(cpuid0_ebx == CPU_GENU_VAL &&
-			cpuid0_edx == CPU_INEI_VAL &&
-			cpuid0_ecx == CPU_NTEL_VAL))
+	if (cpuid0_eax == 0)
 	{
 		*__intel_cpu_feature_indicator = cpu_feature_indicator;
 		return;
 	}
 
+
+    is_intel = (cpuid0_ebx == CPU_GENU_VAL && cpuid0_edx == CPU_INEI_VAL &&
+                cpuid0_ecx == CPU_NTEL_VAL);
+
 #define BEGIN_FEATURE(value) \
     curr_feature = c_feature_##value;
 
@@ -191,14 +193,18 @@
 
     BEGIN_FEATURE(rdrnd)     CPUID_EAX1_ECX_VALUE(1 << 30)   END_FEATURE
     BEGIN_FEATURE(bmi)       CPUID_EAX7_ECX0_EBX_VALUE((1 << 3) | (1 << 8)) END_FEATURE
-    BEGIN_FEATURE(sgx)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 2)   END_FEATURE
-    BEGIN_FEATURE(hle)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 4)   END_FEATURE
-    BEGIN_FEATURE(rtm)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 11)  END_FEATURE
+    if (is_intel) {
+        BEGIN_FEATURE(sgx)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 2)   END_FEATURE
+        BEGIN_FEATURE(hle)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 4)   END_FEATURE
+        BEGIN_FEATURE(rtm)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 11)  END_FEATURE
+    }
     BEGIN_FEATURE(adx)       CPUID_EAX7_ECX0_EBX_VALUE(1 << 19)  END_FEATURE
     BEGIN_FEATURE(rdseed)    CPUID_EAX7_ECX0_EBX_VALUE(1 << 18)  END_FEATURE
     BEGIN_FEATURE(clwb)      CPUID_EAX7_ECX0_EBX_VALUE(1 << 24)  END_FEATURE
 
-    BEGIN_FEATURE(lzcnt)     CPUID_EAX80000001_ECX_VALUE(1 << 5) END_FEATURE
+    if (is_intel) {
+        BEGIN_FEATURE(lzcnt)     CPUID_EAX80000001_ECX_VALUE(1 << 5) END_FEATURE
+    }
     BEGIN_FEATURE(wbnoinvd)  CPUID_EAX80000008_EBX_VALUE(1 << 9) END_FEATURE
 
     BEGIN_FEATURE(gfni)      CPUID_EAX7_ECX0_ECX_VALUE(1 << 8)   END_FEATURE
diff -Nur psw/urts/cpu_features.h psw/urts/cpu_features.h
--- psw/urts/cpu_features.h
+++ psw/urts/cpu_features.h
@@ -32,6 +32,8 @@
 #ifndef _CPU_FEATURES_H_
 #define _CPU_FEATURES_H_
 
+#include <stdint.h>
+
 #include "cpuid.h"
 
 void init_cpuinfo(uint32_t *cpuinfo_table);
diff -Nur psw/urts/enclave.cpp psw/urts/enclave.cpp
--- psw/urts/enclave.cpp
+++ psw/urts/enclave.cpp
@@ -43,10 +43,12 @@
 #include "rts_cmd.h"
 #include <assert.h>
 #include "rts.h"
+#include <unistd.h>
 
 
 int do_ecall(const int fn, const void *ocall_table, const void *ms, CTrustThread *trust_thread);
 int do_ocall(const bridge_fn_t bridge, void *ms);
+extern se_thread_id_t get_thread_id();
 
 CEnclave::CEnclave()
     : m_enclave_id(0)
@@ -65,6 +67,8 @@
     , m_sealed_key(NULL)
     , m_uswitchless(NULL)
     , m_us_has_started(false)
+    , m_process_id(0)
+    , m_user_utility_thread_id(0)
     , m_dynamic_tcs_list_size(0)
 {
     memset(&m_enclave_info, 0, sizeof(debug_enclave_info_t));
@@ -96,7 +100,7 @@
         goto on_exit;
     }
 
-    status = ecall(ECMD_INIT_SWITCHLESS, NULL, m_uswitchless);
+    status = ecall(ECMD_INIT_SWITCHLESS, NULL, m_uswitchless, /*is_utility=*/false);
     if (status != SGX_SUCCESS) goto on_exit;
 
     if (sl_uswitchless_init_workers(m_uswitchless)) {
@@ -267,6 +271,10 @@
     m_sealed_key = sealed_key;
 }
 
+pid_t CEnclave::process_id() { return m_process_id; }
+
+void CEnclave::set_process_id() { m_process_id = getpid(); }
+
 sgx_status_t CEnclave::error_trts2urts(unsigned int trts_error)
 {
     if(trts_error == (unsigned int)SE_ERROR_READ_LOCK_FAIL)
@@ -284,7 +292,7 @@
     return (sgx_status_t)trts_error;
 }
 
-sgx_status_t CEnclave::ecall(const int proc, const void *ocall_table, void *ms, const bool is_switchless)
+sgx_status_t CEnclave::ecall(const int proc, const void *ocall_table, void *ms, bool is_utility, const bool is_switchless)
 {
     if(se_try_rdlock(&m_rwlock))
     {
@@ -316,7 +324,20 @@
 on_fallback:
         //Handle normal ECall or fallback'ed switchless ECall
         //do sgx_ecall
-        CTrustThread *trust_thread = get_tcs(proc);
+        int ecmd = proc;
+        // If a utility tcs is active and its untrusted thread is interrupted by
+        // an exception, the exception is generated from the utility thread and
+        // we should enter the enclave through utility tcs.
+        if (m_user_utility_thread_id == get_thread_id() && proc == ECMD_EXCEPT)
+        {
+            ecmd = ECMD_UTILITY_EXCEPT;
+        }
+        //If this is a utility ecall, use the utility thread.
+        else if (is_utility)
+        {
+            ecmd = ECMD_UTILITY;
+        }
+        CTrustThread *trust_thread = get_tcs(ecmd);
         unsigned ret = SGX_ERROR_OUT_OF_TCS;
 
         if(NULL != trust_thread)
@@ -358,7 +379,20 @@
                 }
             }
 
+            // Entering the enclave through the utility tcs. Set the utility
+            // thread id so that coming exception handlings in the same
+            // untrusted thread will enter the enclave through utility tcs.
+            if (is_utility)
+            {
+                m_user_utility_thread_id = get_thread_id();
+            }
             ret = do_ecall(proc, ocall_table, ms, trust_thread);
+            // Exited the enclave through the utility tcs. Reset the utility
+            // thread id.
+            if (is_utility)
+            {
+                m_user_utility_thread_id = 0;
+            }
         }
         put_tcs(trust_thread);
 
@@ -432,7 +466,6 @@
 }
 
 
-
 CTrustThread * CEnclave::get_tcs(int ecall_cmd)
 {
     CTrustThread *trust_thread = m_thread_pool->acquire_thread(ecall_cmd);
@@ -530,9 +563,9 @@
     //m_loader.destroy_enclave();
 }
 
-void CEnclave::add_thread(tcs_t * const tcs, bool is_unallocated)
+void CEnclave::add_thread(tcs_t * const tcs, bool is_unallocated, bool enable_user_utility)
 {
-    CTrustThread *trust_thread = m_thread_pool->add_thread(tcs, this, is_unallocated);
+    CTrustThread *trust_thread = m_thread_pool->add_thread(tcs, this, is_unallocated, enable_user_utility);
     if(!is_unallocated)
     {
         insert_debug_tcs_info_head(&m_enclave_info, trust_thread->get_debug_info());
diff -Nur psw/urts/enclave_creator_hw_com.cpp psw/urts/enclave_creator_hw_com.cpp
--- psw/urts/enclave_creator_hw_com.cpp
+++ psw/urts/enclave_creator_hw_com.cpp
@@ -69,8 +69,9 @@
     if (is_EDMM_supported(enclave_id))
             info.system_feature_set[0] |= EDMM_ENABLE_BIT;
 
-
-    int status = enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info));
+    int status =
+        enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info),
+                       /*is_utility=*/false);
     //free the tcs used by initialization;
     enclave->get_thread_pool()->reset();
 
diff -Nur psw/urts/enclave.h psw/urts/enclave.h
--- psw/urts/enclave.h
+++ psw/urts/enclave.h
@@ -33,6 +33,8 @@
 #ifndef _ENCLAVE_H_
 #define _ENCLAVE_H_
 
+#include <unistd.h>
+
 #include "se_wrapper.h"
 #include "tcs.h"
 #include "create_param.h"
@@ -57,7 +59,7 @@
     size_t get_dynamic_tcs_list_size();
     CTrustThreadPool * get_thread_pool() { return m_thread_pool; }
     uint64_t get_size() { return m_size; };
-    sgx_status_t ecall(const int proc, const void *ocall_table, void *ms, const bool is_fast = false);
+    sgx_status_t ecall(const int proc, const void *ocall_table, void *ms, bool is_utility, const bool is_switchless = false);
     int ocall(const unsigned int proc, const sgx_ocall_table_t *ocall_table, void *ms);
     void destroy();
     uint32_t atomic_inc_ref() { return se_atomic_inc(&m_ref); }
@@ -66,7 +68,7 @@
     void mark_zombie()  { m_zombie = true; }
     bool is_zombie() { return m_zombie; }
     sgx_status_t initialize(const se_file_t& file, CLoader &ldr, const uint64_t enclave_size, const uint32_t tcs_policy, const uint32_t enclave_version, const uint32_t tcs_min_pool);
-    void add_thread(tcs_t * const tcs, bool is_unallocated);
+    void add_thread(tcs_t * const tcs, bool is_unallocated, bool enable_user_utility);
     void add_thread(CTrustThread * const trust_thread);
     const debug_enclave_info_t* get_debug_info();
     void set_dbg_flag(bool dbg_flag) { m_dbg_flag = dbg_flag; }
@@ -84,6 +86,8 @@
     void set_sealed_key(uint8_t *sealed_key);
     sgx_status_t init_uswitchless(const sgx_uswitchless_config_t* config);
     void destroy_uswitchless(void);
+    void set_process_id();
+    pid_t process_id();
     sgx_target_info_t get_target_info();
 #ifdef SE_SIM
     void *get_global_data_sim_ptr();
@@ -118,7 +122,9 @@
     uint8_t                 *m_sealed_key;
     struct sl_uswitchless*  m_uswitchless;
     bool                    m_us_has_started;
+    pid_t                   m_process_id;
     sgx_target_info_t       m_target_info;
+    se_thread_id_t          m_user_utility_thread_id;
     size_t                  m_dynamic_tcs_list_size;
 #ifdef SE_SIM    
     void                    *m_global_data_sim_ptr;
diff -Nur psw/urts/file.h psw/urts/file.h
--- psw/urts/file.h
+++ psw/urts/file.h
@@ -33,6 +33,8 @@
 #ifndef _FILE_H_
 #define _FILE_H_
 
+#include <stdint.h>
+
 typedef char*  prd_css_path_t;
 
 typedef struct _se_file_t {
diff -Nur psw/urts/linux/enclave_creator_hw.cpp psw/urts/linux/enclave_creator_hw.cpp
--- psw/urts/linux/enclave_creator_hw.cpp
+++ psw/urts/linux/enclave_creator_hw.cpp
@@ -52,9 +52,7 @@
 
 #define POINTER_TO_U64(A) ((__u64)((uintptr_t)(A)))
   
-static EnclaveCreatorHW g_enclave_creator_hw;
-
-EnclaveCreator* g_enclave_creator = &g_enclave_creator_hw;
+EnclaveCreator* g_enclave_creator = new EnclaveCreatorHW;
 static uint64_t g_eid = 0x1;
 
 
@@ -174,10 +172,10 @@
 
     enclave_create_sgx_t enclave_create_sgx = {0};
     if (0 != memcpy_s(enclave_create_sgx.secs, SECS_SIZE, secs, SECS_SIZE))
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_OUT_OF_MEMORY;
 
     uint32_t enclave_error = ENCLAVE_ERROR_SUCCESS;
-    void* enclave_base = enclave_create(NULL, (size_t)secs->size, 0, ENCLAVE_TYPE_SGX2, &enclave_create_sgx, sizeof(enclave_create_sgx_t), &enclave_error);
+    void* enclave_base = enclave_create(*start_addr, (size_t)secs->size, 0, ENCLAVE_TYPE_SGX2, &enclave_create_sgx, sizeof(enclave_create_sgx_t), &enclave_error);
 
     if (enclave_error)
         return error_api2urts(enclave_error);
@@ -211,7 +209,7 @@
 
     enclave_init_sgx_t enclave_init_sgx = {0};
     if (0 != memcpy_s(enclave_init_sgx.sigstruct, SIGSTRUCT_SIZE, enclave_css, SIGSTRUCT_SIZE))
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_OUT_OF_MEMORY;
 
     uint32_t enclave_error = ENCLAVE_ERROR_SUCCESS;
     enclave_initialize((void*)enclave_id, &enclave_init_sgx, sizeof(enclave_init_sgx), &enclave_error);
diff -Nur psw/urts/linux/read_xcr0.h psw/urts/linux/read_xcr0.h
--- psw/urts/linux/read_xcr0.h
+++ psw/urts/linux/read_xcr0.h
@@ -33,6 +33,8 @@
 #ifndef _READ_XCR0_H_
 #define _READ_XCR0_H_
 
+#include <stdint.h>
+
 static inline uint64_t xgetbv(uint32_t index)
 {
     uint32_t eax, edx;
diff -Nur psw/urts/linux/sig_handler.cpp psw/urts/linux/sig_handler.cpp
--- psw/urts/linux/sig_handler.cpp
+++ psw/urts/linux/sig_handler.cpp
@@ -113,7 +113,8 @@
         //If exception is raised in trts again and again, the SSA will overflow, and finally it is EENTER exception.
         assert(reinterpret_cast<tcs_t *>(xbx) == param->tcs);
         CEnclave *enclave = param->trust_thread->get_enclave();
-        unsigned int ret = enclave->ecall(ECMD_EXCEPT, param->ocall_table, NULL);
+        unsigned int ret = enclave->ecall(ECMD_EXCEPT, param->ocall_table, NULL,
+                                          /*is_utility=*/false);
         if(SGX_SUCCESS == ret)
         {
             //ERESUME execute
@@ -198,23 +199,11 @@
     }
     else
     {
-        sigdelset(&sig_act.sa_mask, SIGSEGV);
-        sigdelset(&sig_act.sa_mask, SIGFPE);
         sigdelset(&sig_act.sa_mask, SIGILL);
-        sigdelset(&sig_act.sa_mask, SIGBUS);
-        sigdelset(&sig_act.sa_mask, SIGTRAP);
     }
 
-    ret = sigaction(SIGSEGV, &sig_act, &g_old_sigact[SIGSEGV]);
-    if (0 != ret) abort();
-    ret = sigaction(SIGFPE, &sig_act, &g_old_sigact[SIGFPE]);
-    if (0 != ret) abort();
     ret = sigaction(SIGILL, &sig_act, &g_old_sigact[SIGILL]);
     if (0 != ret) abort();
-    ret = sigaction(SIGBUS, &sig_act, &g_old_sigact[SIGBUS]);
-    if (0 != ret) abort();
-    ret = sigaction(SIGTRAP, &sig_act, &g_old_sigact[SIGTRAP]);
-    if (0 != ret) abort();
 }
 
 //trust_thread is saved at stack for ocall.
@@ -231,8 +220,11 @@
     CEnclave* enclave = trust_thread->get_enclave();
     //check if it is current pid, it is to simulate fork() scenario on HW
     sgx_enclave_id_t eid = enclave->get_enclave_id();
-    if((pid_t)(eid >> 32) != getpid())
-        return SGX_ERROR_ENCLAVE_LOST;
+    // If process id is set, this is an enclave created by enclave_fork. Check
+    // the process id instead of the enclave id.
+    if ((enclave->process_id() != 0 && enclave->process_id() != getpid()) ||
+        (enclave->process_id() == 0 && (pid_t)(eid >> 32) != getpid()))
+      return SGX_ERROR_ENCLAVE_LOST;
 #endif
 
     tcs_t *tcs = trust_thread->get_tcs();
diff -Nur psw/urts/linux/urts.cpp psw/urts/linux/urts.cpp
--- psw/urts/linux/urts.cpp
+++ psw/urts/linux/urts.cpp
@@ -29,7 +29,8 @@
  *
  */
 
-
+#include "arch.h"
+#include "enclave.h"
 #include "sgx_error.h"
 #include "sgx_urts.h"
 #include "sgx_uswitchless.h"
@@ -37,13 +38,15 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
+#include <sys/mman.h>
+#include <iostream>
 
 #include "urts_com.h"
 
 static bool inline _check_ex_params_(const uint32_t ex_features, const void* ex_features_p[32])
 {
     //update last feature index if it fails here
-    se_static_assert(_SGX_LAST_EX_FEATURE_IDX_ == SGX_CREATE_ENCLAVE_EX_KSS_BIT_IDX);
+    se_static_assert(_SGX_LAST_EX_FEATURE_IDX_ == SGX_CREATE_ENCLAVE_EX_ASYLO_BIT_IDX);
     
     uint32_t i;
 
@@ -65,6 +68,30 @@
     return ((ex_features | _SGX_EX_FEATURES_MASK_) == _SGX_EX_FEATURES_MASK_);
 }
 
+static sgx_status_t place_enclave(const uint32_t ex_features, const void* ex_features_p[32])
+{
+    asylo_sgx_config_t *asylo_config = nullptr;
+    int has_feature = get_ex_feature_pointer(SGX_CREATE_ENCLAVE_EX_ASYLO, ex_features,
+                                ex_features_p, (void**)&asylo_config);
+    if (has_feature == -1) {
+      return SGX_ERROR_INVALID_PARAMETER;
+    } else if (has_feature == 0) {
+      return SGX_SUCCESS;
+    }
+    // Reserve the memory to load the enclave if the address to load the enclave
+    // is specified.
+    if (asylo_config->base_address && *asylo_config->base_address &&
+        asylo_config->enclave_size > 0)
+    {
+        void *reserved_address = mmap(*asylo_config->base_address,
+                                      asylo_config->enclave_size, PROT_NONE,
+                                      MAP_SHARED | MAP_ANONYMOUS, -1, 0);
+        if (reserved_address != *asylo_config->base_address)
+            return SGX_ERROR_MEMORY_MAP_CONFLICT;
+    }
+    return SGX_SUCCESS;
+}
+
 extern "C" sgx_status_t __sgx_create_enclave_ex(const char *file_name, 
                                                 const int debug, 
                                                 sgx_launch_token_t *launch_token, 
@@ -74,7 +101,10 @@
                                                 const uint32_t ex_features,
                                                 const void* ex_features_p[32])
 {
-    sgx_status_t ret = SGX_SUCCESS;
+    sgx_status_t ret = place_enclave(ex_features, ex_features_p);
+    if (ret != SGX_SUCCESS) {
+      return ret;
+    }
 
     //Only true or false is valid
     if(TRUE != debug &&  FALSE != debug)
@@ -92,7 +122,7 @@
         return SGX_ERROR_ENCLAVE_FILE_ACCESS;
     }
     se_file_t file = {NULL, 0, false};
-    char resolved_path[PATH_MAX];
+    char resolved_path[PATH_MAX] = {0};
     file.name = realpath(file_name, resolved_path);
     file.name_len = (uint32_t)strnlen_s(resolved_path, PATH_MAX);
 
@@ -158,7 +188,10 @@
                                                           const uint32_t ex_features,
                                                           const void* ex_features_p[32])
 {
-    sgx_status_t ret = SGX_SUCCESS;
+    sgx_status_t ret = place_enclave(ex_features, ex_features_p);
+    if (ret != SGX_SUCCESS) {
+      return ret;
+    }
 
     // Only true or false is valid
     if (TRUE != debug &&  FALSE != debug)
diff -Nur psw/urts/loader.cpp psw/urts/loader.cpp
--- psw/urts/loader.cpp
+++ psw/urts/loader.cpp
@@ -48,7 +48,9 @@
 #include <vector>
 #include <tuple>
 #include <algorithm>
+#ifndef __STDC_FORMAT_MACROS
 #define __STDC_FORMAT_MACROS
+#endif  // __STDC_FORMAT_MACROS
 #include <inttypes.h>
 #include <sys/mman.h>
 
@@ -173,7 +175,7 @@
                 {
                     SE_TRACE(SE_TRACE_WARNING, "mprotect(rva=0x%llx, len=%d, flags=%d) failed\n",
                              rva, SE_PAGE_SIZE, int(sinfo.flags & SI_MASK_MEM_ATTRIBUTE));
-                    return SGX_ERROR_UNEXPECTED;
+                    return SGX_ERROR_MEMORY_MAP_CONFLICT;
                 }
             }
         }
@@ -496,7 +498,7 @@
     }
     return SGX_SUCCESS;
 }
-int CLoader::build_secs(sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, sgx_misc_attribute_t * const misc_attr)
+int CLoader::build_secs(sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, void **enclave_base_addr, sgx_config_svn_t config_svn, sgx_misc_attribute_t * const misc_attr)
 {
     memset(&m_secs, 0, sizeof(secs_t)); //should set resvered field of secs as 0.
     //create secs structure.
@@ -516,12 +518,21 @@
 
     EnclaveCreator *enclave_creator = get_enclave_creator();
     if(NULL == enclave_creator)
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_ENCLAVE_CRASHED;
+    if (enclave_base_addr) {
+      // If |enclave_base_addr| is NULL, the address to create the enclave will
+      // be chosen by the kernel by default. Otherwise the enclave is created at
+      // |enclave_base_addr|, unless it's not available.
+      m_start_addr = *enclave_base_addr;
+    }
     int ret = enclave_creator->create_enclave(&m_secs, &m_enclave_id, &m_start_addr, is_ae(&m_metadata->enclave_css));
     if(SGX_SUCCESS == ret)
     {
         SE_TRACE(SE_TRACE_NOTICE, "Enclave start addr. = %p, Size = 0x%llx, %llu KB\n", 
                  m_start_addr, m_metadata->enclave_size, m_metadata->enclave_size/1024);
+        if (enclave_base_addr) {
+          *enclave_base_addr = m_start_addr;
+        }
     }
 	// m_secs.mr_enclave value is not set previously
     if(memcpy_s(&m_secs.mr_enclave, sizeof(sgx_measurement_t), &m_metadata->enclave_css.body.enclave_hash, sizeof(sgx_measurement_t)))
@@ -529,12 +540,12 @@
 
     return ret;
 }
-int CLoader::build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr)
+int CLoader::build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, void **enclave_base_addr, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr)
 {
     int ret = SGX_SUCCESS;
 
 
-    if(SGX_SUCCESS != (ret = build_secs(secs_attr, config_id, config_svn, misc_attr)))
+    if(SGX_SUCCESS != (ret = build_secs(secs_attr, config_id, enclave_base_addr, config_svn, misc_attr)))
     {
         SE_TRACE(SE_TRACE_WARNING, "build secs failed\n");
         return ret;
@@ -770,7 +781,7 @@
     return false;
 }
 
-int CLoader::load_enclave(SGXLaunchToken *lc, int debug, const metadata_t *metadata, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
+int CLoader::load_enclave(SGXLaunchToken *lc, int debug, const metadata_t *metadata, void **enclave_base_addr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
 {
     int ret = SGX_SUCCESS;
     sgx_misc_attribute_t sgx_misc_attr;
@@ -790,7 +801,7 @@
         return ret;
     }
 
-    ret = build_image(lc, &sgx_misc_attr.secs_attr, config_id, config_svn, prd_css_file, &sgx_misc_attr);
+    ret = build_image(lc, &sgx_misc_attr.secs_attr, config_id, enclave_base_addr, config_svn, prd_css_file, &sgx_misc_attr);
     // Update misc_attr with secs.attr upon success.
     if(SGX_SUCCESS == ret)
     {
@@ -806,14 +817,14 @@
     return ret;
 }
 
-int CLoader::load_enclave_ex(SGXLaunchToken *lc, bool debug, const metadata_t *metadata, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
+int CLoader::load_enclave_ex(SGXLaunchToken *lc, bool debug, const metadata_t *metadata, void **enclave_base_addr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t *misc_attr)
 {
     unsigned int ret = SGX_SUCCESS, map_conflict_count = 3;
     bool retry = true;
 
     while (retry)
     {
-        ret = this->load_enclave(lc, debug, metadata, config_id, config_svn, prd_css_file, misc_attr);
+        ret = this->load_enclave(lc, debug, metadata, enclave_base_addr, config_id, config_svn, prd_css_file, misc_attr);
         switch(ret)
         {
             //If CreateEnclave failed due to power transition, we retry it.
@@ -849,7 +860,7 @@
     //set memory protection for segments
     if(m_parser.set_memory_protection((uint64_t)m_start_addr, is_after_initialization) != true)
     {
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_MEMORY_MAP_CONFLICT;
     }
 
     if (is_after_initialization &&
@@ -920,7 +931,7 @@
                          (uint64_t)m_start_addr + layout->entry.rva + delta, 
                          (uint64_t)layout->entry.page_count << SE_PAGE_SHIFT, 
                           prot);
-                return SGX_ERROR_UNEXPECTED;
+                return SGX_ERROR_MEMORY_MAP_CONFLICT;
             }
         }
         else
diff -Nur psw/urts/loader.h psw/urts/loader.h
--- psw/urts/loader.h
+++ psw/urts/loader.h
@@ -57,8 +57,8 @@
 public:
     CLoader(uint8_t *mapped_file_base, BinParser &parser);
     virtual ~CLoader();
-    int load_enclave(SGXLaunchToken *lc, int flag, const metadata_t *metadata, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
-    int load_enclave_ex(SGXLaunchToken *lc, bool is_debug, const metadata_t *metadata, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
+    int load_enclave(SGXLaunchToken *lc, int debug, const metadata_t *metadata, void **enclave_base_addr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
+    int load_enclave_ex(SGXLaunchToken *lc, bool debug, const metadata_t *metadata, void **enclave_base_addr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file = NULL, sgx_misc_attribute_t *misc_attr = NULL);
     int destroy_enclave();
     sgx_enclave_id_t get_enclave_id() const;
     const void* get_start_addr() const;
@@ -71,8 +71,8 @@
 
 private:
     int build_mem_region(const section_info_t &sec_info);
-    int build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr);
-    int build_secs(sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, sgx_config_svn_t config_svn, sgx_misc_attribute_t * const misc_attr);
+    int build_image(SGXLaunchToken * const lc, sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, void **enclave_base_addr, sgx_config_svn_t config_svn, le_prd_css_file_t *prd_css_file, sgx_misc_attribute_t * const misc_attr);
+    int build_secs(sgx_attributes_t * const secs_attr, sgx_config_id_t *config_id, void **enclave_base_addr, sgx_config_svn_t config_svn, sgx_misc_attribute_t * const misc_attr);
     int build_context(const uint64_t start_rva, layout_entry_t *layout);
     int build_contexts(layout_t *layout_start, layout_t *layout_end, uint64_t delta);
     int build_partial_page(const uint64_t rva, const uint64_t size, const void *source, const sec_info_t &sinfo, const uint32_t attr);
diff -Nur psw/urts/parser/elfparser.cpp psw/urts/parser/elfparser.cpp
--- psw/urts/parser/elfparser.cpp
+++ psw/urts/parser/elfparser.cpp
@@ -111,28 +111,49 @@
 bool validate_elf_header(const ElfW(Ehdr) *elf_hdr)
 {
     // validate magic number
-    if (memcmp(&elf_hdr->e_ident, ELFMAG, SELFMAG))
+    if (memcmp(&elf_hdr->e_ident, ELFMAG, SELFMAG)) {
+        SE_TRACE(SE_TRACE_ERROR, "Incorrect magic number\n");
         return false;
+    }
 
 #if RTS_SYSTEM_WORDSIZE == 64
-    if (ELFCLASS64 != elf_hdr->e_ident[EI_CLASS])
+    if (ELFCLASS64 != elf_hdr->e_ident[EI_CLASS]) {
+        SE_TRACE(SE_TRACE_ERROR, "Expected ELFCLASS64: 0x%x\n",
+                 elf_hdr->e_ident[EI_CLASS]);
         return false;
+    }
 #else
-    if (ELFCLASS32 != elf_hdr->e_ident[EI_CLASS])
+    if (ELFCLASS32 != elf_hdr->e_ident[EI_CLASS]) {
+        SE_TRACE(SE_TRACE_ERROR, "Expected ELFCLASS32: 0x%x\n",
+                 elf_hdr->e_ident[EI_CLASS]);
         return false;
+    }
 #endif
 
-    if (ELFDATA2LSB!= elf_hdr->e_ident[EI_DATA])
+    if (ELFDATA2LSB!= elf_hdr->e_ident[EI_DATA]) {
+        SE_TRACE(SE_TRACE_ERROR, "Expected ELFDATA2LSB: 0x%x\n",
+                 elf_hdr->e_ident[EI_DATA]);
         return false;
+    }
 
-    if (EV_CURRENT != elf_hdr->e_ident[EI_VERSION])
+    if (EV_CURRENT != elf_hdr->e_ident[EI_VERSION]) {
+        SE_TRACE(SE_TRACE_ERROR, "Expected EV_CURRENT: 0x%x\n",
+                 elf_hdr->e_ident[EI_VERSION]);
         return false;
+    }
 
-    if (ET_DYN != elf_hdr->e_type)
+    if (ET_DYN != elf_hdr->e_type) {
+        SE_TRACE(SE_TRACE_ERROR, "Expected ET_DYN: 0x%x\n",
+                 elf_hdr->e_type);
         return false;
+    }
 
-    if (sizeof(ElfW(Phdr)) != elf_hdr->e_phentsize)
+    if (sizeof(ElfW(Phdr)) != elf_hdr->e_phentsize) {
+        SE_TRACE(SE_TRACE_ERROR, "Expected phentsize == %d, got %d\n",
+                 sizeof(ElfW(Phdr)),
+                 elf_hdr->e_phentsize);
         return false;
+    }
 
     return true;
 }
@@ -608,45 +629,60 @@
     if (m_sections.size() != 0) return SGX_SUCCESS;
 
     const ElfW(Ehdr) *elf_hdr = (const ElfW(Ehdr) *)m_start_addr;
-    if (elf_hdr == NULL || m_len < sizeof(ElfW(Ehdr)))
+    if (elf_hdr == NULL || m_len < sizeof(ElfW(Ehdr))) {
+        SE_TRACE_ERROR("Header invalid size\n");
         return SGX_ERROR_INVALID_ENCLAVE;
-
+    }
     /* Check elf header*/
-    if (!validate_elf_header(elf_hdr))
+    if (!validate_elf_header(elf_hdr)) {
+        SE_TRACE_ERROR("Header invalid\n");
         return SGX_ERROR_INVALID_ENCLAVE;
-
+    }
     /* Get and check machine mode */
-    if (!get_bin_fmt(elf_hdr, m_bin_fmt))
+    if (!get_bin_fmt(elf_hdr, m_bin_fmt)) {
+        SE_TRACE_ERROR("Bin fmt incorrect\n");
         return SGX_ERROR_MODE_INCOMPATIBLE;
+    }
 
     /* Check if there is any overlap segment, and make sure the segment is 1 page aligned;
     * TLS segment must exist.
     */
-    if (!validate_segment(elf_hdr, m_len))
+    if (!validate_segment(elf_hdr, m_len)) {
+        SE_TRACE_ERROR("Segment incorrect\n");
         return SGX_ERROR_INVALID_ENCLAVE;
+    }
 
-    if (!parse_dyn(elf_hdr, &m_dyn_info[0]))
+    if (!parse_dyn(elf_hdr, &m_dyn_info[0])) {
+        SE_TRACE_ERROR("Dyn incorrect\n");
         return SGX_ERROR_INVALID_ENCLAVE;
+    }
 
     /* Check if there is any undefined symbol */
     if (!check_symbol_table(elf_hdr, m_dyn_info, m_sym_table))
     {
+        SE_TRACE_ERROR("Symbol table incorrect\n");
         return SGX_ERROR_UNDEFINED_SYMBOL;
     }
 
     /* Check if there is unexpected relocation type */
-    if (!validate_reltabs(elf_hdr, m_dyn_info))
+    if (!validate_reltabs(elf_hdr, m_dyn_info)) {
+        SE_TRACE_ERROR("Reltabs incorrect\n");
         return SGX_ERROR_INVALID_ENCLAVE;
+    }
 
     /* Check if there is .ctor section */
-    if (has_ctor_section(elf_hdr))
+    if (has_ctor_section(elf_hdr)) {
+        SE_TRACE_ERROR("ctor section incorrect\n");
         return SGX_ERROR_INVALID_ENCLAVE;
+    }
 
     /* build regular sections */
     if (build_regular_sections(m_start_addr, m_sections, m_tls_section, m_metadata_offset, m_metadata_block_size))
         return SGX_SUCCESS;
-    else
+    else {
+        SE_TRACE_ERROR("Regular sections incorrect\n");
         return SGX_ERROR_INVALID_ENCLAVE;
+    }
 }
 
 ElfParser::~ElfParser()
@@ -856,6 +892,19 @@
         return false;
     }
     *data_size = sizeof(global_data_t);
+
+    // Record the data and bss section address and size.
+    global_data_t *global_data = reinterpret_cast<global_data_t *>(data);
+    const ElfW(Ehdr) *elf_hdr =
+        reinterpret_cast<const ElfW(Ehdr) *>(m_start_addr);
+    const ElfW(Shdr) *shdr = get_section_by_name(elf_hdr, ELF_DATA);
+    global_data->data_offset = static_cast<sys_word_t>(shdr->sh_addr);
+    global_data->data_size = static_cast<sys_word_t>(shdr->sh_size);
+
+    shdr = get_section_by_name(elf_hdr, ELF_BSS);
+    global_data->bss_offset = static_cast<sys_word_t>(shdr->sh_addr);
+    global_data->bss_size = static_cast<sys_word_t>(shdr->sh_size);
+
     return do_update_global_data(metadata, create_param, (global_data_t *)data);
 }
 
diff -Nur psw/urts/parser/update_global_data.hxx psw/urts/parser/update_global_data.hxx
--- psw/urts/parser/update_global_data.hxx
+++ psw/urts/parser/update_global_data.hxx
@@ -29,6 +29,13 @@
  *
  */
 
+#include <stdint.h>
+
+#include "create_param.h"
+#include "global_data.h"
+#include "loader.h"
+#include "thread_data.h"
+
 namespace {
     layout_entry_t *get_entry_by_id(const metadata_t *const metadata, uint16_t id, bool do_assert = true)
     {
diff -Nur psw/urts/routine.cpp psw/urts/routine.cpp
--- psw/urts/routine.cpp
+++ psw/urts/routine.cpp
@@ -37,7 +37,7 @@
 #include "rts_cmd.h"
 
 static
-sgx_status_t _sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, const bool is_switchless)
+sgx_status_t _sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility, const bool is_switchless)
 {
     if ((proc != ECMD_RUN_SWITCHLESS_TWORKER) &&  (proc < 0))
     {
@@ -52,7 +52,7 @@
 
     sgx_status_t result = SGX_ERROR_UNEXPECTED;
     {
-        result = enclave->ecall(proc, ocall_table, ms, is_switchless);
+        result = enclave->ecall(proc, ocall_table, ms, is_utility, is_switchless);
     }
     {
         //This solution seems more readable and easy to validate, but low performace
@@ -63,15 +63,15 @@
 }
 
 extern "C"
-sgx_status_t sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms)
+sgx_status_t sgx_ecall(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility)
 {
-    return _sgx_ecall(enclave_id, proc, ocall_table, ms, false);
+    return _sgx_ecall(enclave_id, proc, ocall_table, ms, is_utility, false);
 }
 
 extern "C"
-sgx_status_t sgx_ecall_switchless(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms)
+sgx_status_t sgx_ecall_switchless(const sgx_enclave_id_t enclave_id, const int proc, const void *ocall_table, void *ms, bool is_utility)
 {
-    return _sgx_ecall(enclave_id, proc, ocall_table, ms, true);
+    return _sgx_ecall(enclave_id, proc, ocall_table, ms, is_utility, true);
 }
 
 extern "C"
diff -Nur psw/urts/tcs.cpp psw/urts/tcs.cpp
--- psw/urts/tcs.cpp
+++ psw/urts/tcs.cpp
@@ -94,8 +94,10 @@
 {
     m_thread_list = NULL;
     m_utility_thread = NULL;
+    m_user_utility_thread = NULL;
     m_tcs_min_pool = tcs_min_pool;
     m_need_to_wait_for_new_thread = false;
+    m_user_utility_thread_in_use = false;
 }
 
 CTrustThreadPool::~CTrustThreadPool()
@@ -130,7 +132,10 @@
         delete m_utility_thread;
         m_utility_thread = NULL;
     }
-
+    if (m_user_utility_thread) {
+      delete m_user_utility_thread;
+      m_user_utility_thread = NULL;
+    }
 }
 
 void get_thread_set(std::vector<se_thread_id_t> &thread_vector);
@@ -209,7 +214,7 @@
     return trust_thread;
 }
 
-CTrustThread * CTrustThreadPool::add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated)
+CTrustThread * CTrustThreadPool::add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated, bool enable_user_utility)
 {
     CTrustThread *trust_thread = new CTrustThread(tcs, enclave);
     LockGuard lock(&m_thread_mutex);
@@ -218,6 +223,8 @@
     {
         if (g_enclave_creator->is_EDMM_supported(enclave->get_enclave_id()) && !m_utility_thread && (enclave->get_dynamic_tcs_list_size() != 0))
             m_utility_thread = trust_thread;
+        else if (enable_user_utility && !m_user_utility_thread)
+            m_user_utility_thread = trust_thread;
         else
             m_free_thread_vector.push_back(trust_thread);
     }
@@ -309,7 +316,8 @@
     //try to get tcs from thread cache
     se_thread_id_t thread_id = get_thread_id();
     CTrustThread *trust_thread = get_bound_thread(thread_id);
-    if(NULL != trust_thread  && m_utility_thread != trust_thread)
+    if(NULL != trust_thread  && m_utility_thread != trust_thread &&
+        m_user_utility_thread != trust_thread)
     {
         return trust_thread;
     }
@@ -334,7 +342,8 @@
     LockGuard lock(&m_thread_mutex);
     CTrustThread *trust_thread = NULL;
     bool is_special_ecall = (ecall_cmd == ECMD_INIT_ENCLAVE) || (ecall_cmd == ECMD_UNINIT_ENCLAVE) ;
-    
+    bool is_user_utility = (ecall_cmd == ECMD_UTILITY || ecall_cmd == ECMD_UTILITY_EXCEPT);
+    bool is_user_utility_exception = (ecall_cmd == ECMD_UTILITY_EXCEPT);
 
     if(is_special_ecall == true)
     {
@@ -357,6 +366,21 @@
             trust_thread = _acquire_thread();
         }
     }
+    else if (is_user_utility)
+    {
+      if (m_user_utility_thread) {
+        // An active user utility thread could be used to enter the enclave
+        // only if it is for exception handling.
+        if (m_user_utility_thread_in_use.exchange(true) && !is_user_utility_exception)
+        {
+            return NULL;
+        }
+        trust_thread = m_user_utility_thread;
+        assert(trust_thread != NULL);
+      } else {
+        return NULL;
+      }
+    }
     else
     {
         trust_thread = _acquire_thread();
@@ -392,6 +416,9 @@
 //Do nothing for bind mode, the tcs is always bound to a thread.
 void CTrustThreadPool::release_thread(CTrustThread * const trust_thread)
 {
+  if (trust_thread == m_user_utility_thread) {
+    m_user_utility_thread_in_use = false;
+  }
     LockGuard lock(&m_thread_mutex);
     trust_thread->decrease_ref();
     return;
@@ -454,7 +481,7 @@
 
 sgx_status_t CTrustThreadPool::new_thread()
 {
-    sgx_status_t ret = SGX_ERROR_UNEXPECTED;
+    sgx_status_t ret = SGX_ERROR_OUT_OF_TCS;
     if(!m_utility_thread)
     {
         return ret;
diff -Nur psw/urts/tcs.h psw/urts/tcs.h
--- psw/urts/tcs.h
+++ psw/urts/tcs.h
@@ -38,6 +38,7 @@
 #include "sgx_error.h"
 #include "se_debugger_lib.h"
 #include "se_lock.hpp"
+#include <atomic>
 #include <vector>
 #include "node.h"
 
@@ -75,7 +76,7 @@
     virtual ~CTrustThreadPool();
     CTrustThread * acquire_thread(int ecall_cmd);
     void release_thread(CTrustThread * const trust_thread);
-    CTrustThread *add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated);
+    CTrustThread *add_thread(tcs_t * const tcs, CEnclave * const enclave, bool is_unallocated, bool enable_user_utility);
     CTrustThread *get_bound_thread(const tcs_t *tcs);
     std::vector<CTrustThread *> get_thread_list();
     void reset();
@@ -103,8 +104,10 @@
 private:
     CTrustThread * _acquire_thread();
     CTrustThread *m_utility_thread;
+    CTrustThread *m_user_utility_thread;
     uint64_t     m_tcs_min_pool;
     bool         m_need_to_wait_for_new_thread;
+    std::atomic_bool m_user_utility_thread_in_use;
 };
 
 class CThreadPoolBindMode : public CTrustThreadPool
diff -Nur psw/urts/urts_com.h psw/urts/urts_com.h
--- psw/urts/urts_com.h
+++ psw/urts/urts_com.h
@@ -67,7 +67,6 @@
 
 
 
-#define GET_FEATURE_POINTER(feature_name, ex_features_p)    ex_features_p[feature_name##_BIT_IDX]
 // Get the corresponding feature pointer for the input feature name
 // This function should only be called for the features which have the corresponding feature structs
 // Return value: 
@@ -79,32 +78,20 @@
     bool fbit_set = (feature_name & ex_features) ? true : false;
     void *pointer = NULL;
     int ret = -1;
+    #define FEATURE_CASE(name) case name:                                \
+        if (ex_features_p != NULL)                                       \
+            pointer = const_cast<void *>(ex_features_p[name##_BIT_IDX]); \
+        if (fbit_set && pointer)                                         \
+            ret = 1;                                                     \
+        else if (!fbit_set && !pointer)                                  \
+            ret = 0;                                                     \
+        break;
     switch(feature_name)
     {
-    case SGX_CREATE_ENCLAVE_EX_PCL:
-        if (ex_features_p != NULL)
-            pointer = const_cast<void *>(GET_FEATURE_POINTER(SGX_CREATE_ENCLAVE_EX_PCL, ex_features_p));
-        if (fbit_set && pointer)
-            ret = 1;
-        else if (!fbit_set && !pointer)
-            ret = 0;
-        break;
-    case SGX_CREATE_ENCLAVE_EX_SWITCHLESS:
-        if (ex_features_p != NULL)
-            pointer = const_cast<void *>(GET_FEATURE_POINTER(SGX_CREATE_ENCLAVE_EX_SWITCHLESS, ex_features_p));
-        if (fbit_set && pointer)
-            ret = 1;
-        else if (!fbit_set && !pointer)
-            ret = 0;
-        break;
-    case SGX_CREATE_ENCLAVE_EX_KSS:
-        if (ex_features_p != NULL)
-            pointer = const_cast<void *>(GET_FEATURE_POINTER(SGX_CREATE_ENCLAVE_EX_KSS, ex_features_p));
-        if (fbit_set && pointer)
-            ret = 1;
-        else if (!fbit_set && !pointer)
-            ret = 0;
-        break;
+    FEATURE_CASE(SGX_CREATE_ENCLAVE_EX_PCL);
+    FEATURE_CASE(SGX_CREATE_ENCLAVE_EX_SWITCHLESS);
+    FEATURE_CASE(SGX_CREATE_ENCLAVE_EX_KSS);
+    FEATURE_CASE(SGX_CREATE_ENCLAVE_EX_ASYLO);
     default:
         break;
     }
@@ -248,19 +235,29 @@
     sgx_config_id_t *config_id = NULL;
     sgx_config_svn_t config_svn = 0;
     sgx_kss_config_t *kss_config = NULL;
+    void **enclave_base_addr = NULL;
+    bool enable_user_utility = false;
+    asylo_sgx_config_t *asylo_config = NULL;
     sgx_uswitchless_config_t* us_config = NULL;
     
     CLoader loader(base_addr, parser);
 
-    if (get_ex_feature_pointer(SGX_CREATE_ENCLAVE_EX_KSS, ex_features, ex_features_p, (void **)&kss_config) == -1)
+    if (get_ex_feature_pointer(SGX_CREATE_ENCLAVE_EX_KSS, ex_features, ex_features_p, (void **)&kss_config) == -1 ||
+        get_ex_feature_pointer(SGX_CREATE_ENCLAVE_EX_ASYLO, ex_features,
+                           ex_features_p, (void**)&asylo_config) == -1)
         return SGX_ERROR_INVALID_PARAMETER;
     if (kss_config)
     {
         config_id = &(kss_config->config_id);
         config_svn = kss_config->config_svn;
     }
+    if (asylo_config)
+    {
+        enclave_base_addr = asylo_config->base_address;
+        enable_user_utility = asylo_config->enable_user_utility;
+    }
 
-    ret = loader.load_enclave_ex(lc, debug, metadata, config_id, config_svn, prd_css_file, misc_attr);
+    ret = loader.load_enclave_ex(lc, debug, metadata, enclave_base_addr, config_id, config_svn, prd_css_file, misc_attr);
     if (ret != SGX_SUCCESS)
     {
         return ret;
@@ -322,13 +319,13 @@
     {
         loader.destroy_enclave();
         delete enclave;
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_INVALID_ENCLAVE;
     }
 
     std::vector<std::pair<tcs_t *, bool>> tcs_list = loader.get_tcs_list();
     for (unsigned idx = 0; idx < tcs_list.size(); ++idx)
     {
-        enclave->add_thread(tcs_list[idx].first, tcs_list[idx].second);
+        enclave->add_thread(tcs_list[idx].first, tcs_list[idx].second, enable_user_utility);
         SE_TRACE(SE_TRACE_DEBUG, "add tcs %p\n", tcs_list[idx].first);
     }
     
@@ -653,7 +650,8 @@
             debug_enclave_info_t *debug_info = const_cast<debug_enclave_info_t *>(enclave->get_debug_info());
             generate_enclave_debug_event(URTS_EXCEPTION_PREREMOVEENCLAVE, debug_info);
             enclave->destroy_uswitchless();
-            enclave->ecall(ECMD_UNINIT_ENCLAVE, NULL, NULL);
+            enclave->ecall(ECMD_UNINIT_ENCLAVE, NULL, NULL,
+                           /*is_utility=*/false);
             CEnclavePool::instance()->unref_enclave(enclave);
         }
     }
@@ -668,4 +666,21 @@
 
     return status;
 }
+
+extern "C" void sgx_set_process_id(const sgx_enclave_id_t enclave_id) {
+#ifdef SE_SIM
+    CEnclave *enclave = CEnclavePool::instance()->get_enclave(enclave_id);
+    enclave->set_process_id();
+#endif  // SE_SIM
+}
+
+extern "C" size_t sgx_enclave_size(const sgx_enclave_id_t enclave_id)
+{
+    CEnclave *enclave = CEnclavePool::instance()->get_enclave(enclave_id);
+    if (enclave)
+    {
+        return enclave->get_size();
+    }
+    return 0;
+}
 #endif
diff -Nur psw/uswitchless/sl_workers_untrusted.c psw/uswitchless/sl_workers_untrusted.c
--- psw/uswitchless/sl_workers_untrusted.c
+++ psw/uswitchless/sl_workers_untrusted.c
@@ -206,7 +206,7 @@
     BUG_ON(workers->handle->us_ocall_table == NULL);
     struct sl_uswitchless* handle = workers->handle;
     sgx_ecall(handle->us_enclave_id, ECMD_RUN_SWITCHLESS_TWORKER,
-              handle->us_ocall_table, NULL);
+              handle->us_ocall_table, NULL, /*is_utility=*/false);
     return 0;
 }
 
diff -Nur sdk/edger8r/linux/Ast.ml sdk/edger8r/linux/Ast.ml
--- sdk/edger8r/linux/Ast.ml
+++ sdk/edger8r/linux/Ast.ml
@@ -154,6 +154,11 @@
   | UnionDef  of union_def
   | EnumDef   of enum_def
 
+(* List of errno values to translate between host and enclave. *)
+type errno_list_type = {
+  errnos: string list;
+}
+
 (* Function declaration. *)
 type func_decl = {
   fname : string;       (* function name. *)
@@ -171,6 +176,8 @@
   tf_fdecl   : func_decl;
   tf_is_priv : bool;   (* private or not, see above comment *)
   tf_is_switchless : bool;
+  tf_is_exception_handler : bool;
+  tf_is_utility : bool;
 }
 
 (* untrust function(aka ocall) declaration. *)
@@ -196,6 +203,7 @@
 type expr =
   | Interface of enclave_func list
   | Composite of composite_type
+  | ErrnoList of errno_list_type
   | Importing of import_decl
   | Include   of string
 
@@ -221,6 +229,7 @@
   include_list : string list;
   import_exprs : import_decl list;
   comp_defs    : composite_type list;
+  errno_list   : errno_list_type list;
   tfunc_decls  : trusted_func   list;
   ufunc_decls  : untrusted_func list;
 }
diff -Nur sdk/edger8r/linux/CodeGen.ml sdk/edger8r/linux/CodeGen.ml
--- sdk/edger8r/linux/CodeGen.ml
+++ sdk/edger8r/linux/CodeGen.ml
@@ -46,6 +46,7 @@
   include_list : string list; (* include another .h *)
   import_exprs : Ast.import_decl list;  (* always empty list after finished reduce_import. *)
   comp_defs    : Ast.composite_type list;
+  errno_list   : Ast.errno_list_type list;
   tfunc_decls  : Ast.trusted_func   list;
   ufunc_decls  : Ast.untrusted_func list;
 }
@@ -75,6 +76,7 @@
     include_list = [];
     import_exprs = [];
     comp_defs    = [];
+    errno_list   = [];
     tfunc_decls  = [];
     ufunc_decls  = []; }
 
@@ -84,6 +86,12 @@
 let is_priv_ecall (tf: Ast.trusted_func) =
   tf.Ast.tf_is_priv
 
+let is_exception_ecall (tf: Ast.trusted_func) =
+  tf.Ast.tf_is_exception_handler
+
+let is_utility_ecall (tf: Ast.trusted_func) =
+  tf.Ast.tf_is_utility
+
 let get_uf_fname (uf: Ast.untrusted_func) =
   uf.Ast.uf_fdecl.Ast.fname
 
@@ -99,6 +107,12 @@
 let tf_list_to_priv_list (tfs: Ast.trusted_func list) =
   List.map is_priv_ecall tfs
 
+let tf_list_to_exception_list (tfs: Ast.trusted_func list) =
+  List.map is_exception_ecall tfs
+
+let tf_list_to_utility_list (tfs: Ast.trusted_func list) =
+  List.map is_utility_ecall tfs
+
 (* Get a list of names of all private ECALLs *)
 let get_priv_ecall_names (tfs: Ast.trusted_func list) =
   List.filter is_priv_ecall tfs |> List.map get_tf_fname
@@ -118,11 +132,13 @@
   let ac_include_list = ref [] in
   let ac_import_exprs = ref [] in
   let ac_comp_defs = ref [] in
+  let ac_errno_list = ref [] in
   let ac_tfunc_decls = ref [] in
   let ac_ufunc_decls = ref [] in
     List.iter (fun ex ->
       match ex with
           Ast.Composite x -> ac_comp_defs := x :: !ac_comp_defs
+        | Ast.ErrnoList x -> ac_errno_list := x :: !ac_errno_list
         | Ast.Include   x -> ac_include_list := x :: !ac_include_list
         | Ast.Importing x -> ac_import_exprs := x :: !ac_import_exprs
         | Ast.Interface xs ->
@@ -138,6 +154,7 @@
       include_list = List.rev !ac_include_list;
       import_exprs = List.rev !ac_import_exprs;
       comp_defs    = List.rev !ac_comp_defs;
+      errno_list   = List.rev !ac_errno_list;
       tfunc_decls  = List.rev !ac_tfunc_decls;
       ufunc_decls  = List.rev !ac_ufunc_decls; }
 
@@ -434,6 +451,62 @@
       | Ast.UnionDef  u -> mk_union_decl  (gen_union_member_list u.Ast.umlist) u.Ast.uname
       | Ast.EnumDef   e -> mk_enum_def    e
 
+(* Generate the internal errno enum definition. *)
+let gen_errno_enum (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_list = List.fold_left (fun acc name ->
+                                    acc ^ "\tSGX_ERRNO_" ^ name ^ ",\n")
+                                  "" all_sorted
+  in
+    if all_errnos = [] then "" else
+      sprintf "enum _sgx_errno_bridge_t {\n%s} sgx_errno_bridge_t;\n" errno_list
+
+(* Generate the function to convert errno values to the internal enum. *)
+let gen_errno_to_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                     acc ^ "\t\tcase " ^ name ^
+                     ":\n\t\t\tvalue = SGX_ERRNO_" ^ name ^
+                     ";\n\t\t\tbreak;\n")
+                   "" all_sorted ^
+    "\t\tdefault:\n\t\t\tvalue |= 0x8000;\n\t\t\tbreak;\n\t}\n"
+    (* The above 0x8000 serves two purposes
+     * 1. Ensures that no host errno values can colide with our enum.
+     *  * Assumes < 32k errno values in enum.
+     * 2. Provides a debugging aide to indicate that errno is host-relative.
+     *)
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_to_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
+(* Generate the function to convert errno values from the internal enum. *)
+let gen_errno_from_conv (el: Ast.errno_list_type list) =
+  let all_errnos = List.fold_left (fun acc l -> acc @ l.Ast.errnos) [] el
+  in
+  let all_sorted = List.sort_uniq compare all_errnos
+  in
+  let errno_switch =
+    "\tswitch(value)\n\t{\n" ^
+    List.fold_left (fun acc name ->
+                      acc ^ "\t\tcase SGX_ERRNO_" ^ name ^
+                      ":\n\t\t\tvalue = " ^ name ^
+                      ";\n\t\t\tbreak;\n")
+                    "" all_sorted ^
+    "\t}\n"
+  in
+    if all_errnos = [] then "" else
+      sprintf "static int bridge_translate_errno_from_internal(int value)\n{\n%s\
+        \treturn value;\n}\n" errno_switch
+
 (* Generate a list of '#include' *)
 let gen_include_list (xs: string list) =
   List.fold_left (fun acc s -> acc ^ sprintf "#include \"%s\"\n" s) "" xs
@@ -478,15 +551,24 @@
 
 (* ---------------------------------------------------------------------- *)
 
+let fold_left4 f arg a b c d =
+  let rec loop arg = function
+    | w::ws, x::xs, y::ys, z::zs -> loop(f arg w x y z) (ws, xs, ys, zs)
+    | [], [], [], [] -> arg
+  in
+  loop arg (a, b, c, d)
+
 (* `gen_ecall_table' is used to generate ECALL table with the following form:
     SGX_EXTERNC const struct {
        size_t nr_ecall;    /* number of ECALLs */
        struct {
            void   *ecall_addr;
            uint8_t is_priv;
+           uint8_t is_exception;
+           uint8_t is_utility;
        } ecall_table [nr_ecall];
    } g_ecall_table = {
-       2, { {sgx_foo, 1}, {sgx_bar, 0} }
+       2, { {sgx_foo, 1, 0, 1}, {sgx_bar, 0, 1, 0} }
    };
 *)
 let gen_ecall_table (tfs: Ast.trusted_func list) =
@@ -494,18 +576,20 @@
   let ecall_table_size = List.length tfs in
   let trusted_fds = tf_list_to_fd_list tfs in
   let priv_bits = tf_list_to_priv_list tfs in
+  let exception_bits = tf_list_to_exception_list tfs in
+  let utility_bits = tf_list_to_utility_list tfs in
   let tbridge_names = List.map (fun (fd: Ast.func_decl) ->
                                   mk_tbridge_name fd.Ast.fname) trusted_fds in
   let ecall_table =
     let bool_to_int b = if b then 1 else 0 in
     let inner_table =
-      List.fold_left2 (fun acc s b ->
-        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d},\n" acc s (bool_to_int b)) "" tbridge_names priv_bits
+      fold_left4 (fun acc s is_priv is_exception_handler is_utility ->
+        sprintf "%s\t\t{(void*)(uintptr_t)%s, %d, %d, %d},\n" acc s (bool_to_int is_priv) (bool_to_int is_exception_handler) (bool_to_int is_utility)) "" tbridge_names priv_bits exception_bits utility_bits
     in "\t{\n" ^ inner_table ^ "\t}\n"
   in
     sprintf "SGX_EXTERNC const struct {\n\
 \tsize_t nr_ecall;\n\
-\tstruct {void* ecall_addr; uint8_t is_priv;} ecall_table[%d];\n\
+\tstruct {void* ecall_addr; uint8_t is_priv; uint8_t is_exception; uint8_t is_utility; } ecall_table[%d];\n\
 } %s = {\n\
 \t%d,\n\
 %s};\n" ecall_table_size
@@ -764,12 +848,18 @@
                                acc ^ ", " ^ mk_parm_name pty dlr) p0 ps)
 
 (* Generate untrusted bridge code for a given untrusted function. *)
-let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) =
+let gen_func_ubridge (file_shortnm: string) (ufunc: Ast.untrusted_func) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (mk_ubridge_proto file_shortnm fd.Ast.fname) in
   let func_close = "\treturn SGX_SUCCESS;\n}\n" in
-  let set_errno = if propagate_errno then "\tms->ocall_errno = errno;" else "" in
+  let set_errno =
+    if propagate_errno then "\tms->ocall_errno = " ^
+      if conv_errno then
+        "bridge_translate_errno_to_internal(errno);"
+      else
+        "errno;"
+    else "" in
   let ms_struct_name = mk_ms_struct_name fd.Ast.fname in
   let declare_ms_ptr = sprintf "%s* %s = SGX_CAST(%s*, %s);"
                                ms_struct_name
@@ -828,6 +918,7 @@
 (* Generate untrusted proxy code for a given trusted function. *)
 let gen_func_uproxy (tf: Ast.trusted_func) (idx: int) (ec: enclave_content) =
   let fd = tf.Ast.tf_fdecl in
+  let is_utility = tf.Ast.tf_is_utility in
   let func_open  =
     gen_uproxy_com_proto fd ec.enclave_name ^
       "\n{\n\tsgx_status_t status;\n"
@@ -841,8 +932,8 @@
   let sgx_ecall_fn = get_sgx_fname SGX_ECALL tf.Ast.tf_is_switchless in
 
   (* Normal case - do ECALL with marshaling structure*)
-  let ecall_with_ms = sprintf "status = %s(%s, %d, %s, &%s);"
-                              sgx_ecall_fn eid_name idx ocall_table_ptr ms_struct_val in
+  let ecall_with_ms = sprintf "status = %s(%s, %d, %s, &%s, %s);"
+                              sgx_ecall_fn eid_name idx ocall_table_ptr ms_struct_val (if is_utility then "true" else "false") in
 
   (* Rare case - the trusted function doesn't have parameter nor return value.
    * In this situation, no marshaling structure is required - passing in NULL.
@@ -1972,7 +2063,7 @@
      List.fold_left (fun acc s -> acc ^ s) s2 do_gen_ocalloc_block
 
 (* Generate trusted proxy code for a given untrusted function. *)
-let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) =
+let gen_func_tproxy (ufunc: Ast.untrusted_func) (idx: int) (conv_errno: bool) =
   let fd = ufunc.Ast.uf_fdecl in
   let propagate_errno = ufunc.Ast.uf_propagate_errno in
   let func_open = sprintf "%s\n{\n" (gen_tproxy_proto fd) in
@@ -2105,7 +2196,13 @@
                              Ast.PTVal _ -> acc
                | Ast.PTPtr(ty, attr) -> acc ^ copy_memory ty attr declr) "" plist in
 
-  let set_errno = if propagate_errno then "\t\terrno = ms->ocall_errno;\n" else "" in
+  let set_errno =
+    if propagate_errno then "\terrno = " ^
+      if conv_errno then
+        "bridge_translate_errno_from_internal(ms->ocall_errno);"
+      else
+        "ms->ocall_errno;"
+    else "" in
   let func_close = sprintf "%s%s%s\n%s%s\n"
                            (handle_out_ptr fd.Ast.plist)
                            set_errno
@@ -2147,7 +2244,7 @@
         (fun acc proto -> acc ^ "\t\t(void*)" ^ proto ^ ",\n") "" func_proto_ubridge
     in "\t{\n" ^ ocall_members ^ "\t}\n"
   in
-    sprintf "static const struct {\n\
+    sprintf "SGX_EXTERNC const struct {\n\
 \tsize_t nr_ocall;\n\
 \tvoid * table[%d];\n\
 } %s = {\n\
@@ -2167,12 +2264,16 @@
       ec.tfunc_decls
       (Util.mk_seq 0 (List.length ec.tfunc_decls - 1))
   in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_to_conv ec.errno_list in
   let ubridge_list =
-    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd)
+    List.map (fun fd -> gen_func_ubridge ec.file_shortnm fd (errno_enum <> ""))
       (ec.ufunc_decls) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ include_errno ^ "\n");
     ms_writer out_chan ec;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     List.iter (fun s -> output_string out_chan (s ^ "\n")) ubridge_list;
     output_string out_chan (gen_ocall_table ec);
     List.iter (fun s -> output_string out_chan (s ^ "\n")) uproxy_list;
@@ -2214,14 +2315,18 @@
     List.map (fun tfd -> gen_func_tbridge tfd dummy_var) trusted_fds in
   let ecall_table = gen_ecall_table ec.tfunc_decls in
   let entry_table = gen_entry_table ec in
+  let errno_enum = gen_errno_enum ec.errno_list in
+  let errno_conv = gen_errno_from_conv ec.errno_list in
   let tproxy_list = List.map2
-                      (fun fd idx -> gen_func_tproxy fd idx)
+                      (fun fd idx -> gen_func_tproxy fd idx (errno_enum <> ""))
                       (ec.ufunc_decls)
                       (Util.mk_seq 0 (List.length ec.ufunc_decls - 1)) in
   let out_chan = open_out code_fname in
     output_string out_chan (include_hd ^ "\n");
     ms_writer out_chan ec;
     List.iter (fun s -> output_string out_chan (s ^ "\n")) tbridge_list;
+    output_string out_chan (errno_enum ^ "\n");
+    output_string out_chan (errno_conv ^ "\n");
     output_string out_chan (ecall_table ^ "\n");
     output_string out_chan (entry_table ^ "\n");
     output_string out_chan "\n";
@@ -2324,10 +2429,18 @@
   in
     List.iter check_ecall priv_ecall_names
 
-(* Check that there is at least one public ECALL function. *)
-let check_priv_funcs (ec: enclave_content) =
+let rec for_all3 f l1 l2 l3 =
+    match (l1, l2, l3) with
+      ([], [], []) -> true
+    | (a1::l1, a2::l2, a3::l3) -> f a1 a2 a3 && for_all3 f l1 l2 l3
+    | (_, _, _) -> invalid_arg "for_all3"
+
+(* Check that there is at least one public and non exception or utility ECALL function. *)
+let check_priv_and_utility_funcs (ec: enclave_content) =
   let priv_bits = tf_list_to_priv_list ec.tfunc_decls in
-  if List.for_all (fun is_priv -> is_priv) priv_bits
+  let exception_bits = tf_list_to_exception_list ec.tfunc_decls in
+  let utility_bits = tf_list_to_utility_list ec.tfunc_decls in
+  if for_all3 (fun is_priv is_exception_handler is_utility -> is_priv || is_exception_handler || is_utility) priv_bits exception_bits utility_bits
   then failwithf "the enclave `%s' contains no public root ECALL.\n" ec.file_shortnm
   else report_orphaned_priv_ecall ec
 
@@ -2420,6 +2533,7 @@
         include_list = acc.include_list @ ec2.include_list;
         import_exprs = [];
         comp_defs    = acc.comp_defs   @ ec2.comp_defs;
+        errno_list   = acc.errno_list  @ ec2.errno_list;
         tfunc_decls  = acc.tfunc_decls @ ec2.tfunc_decls;
         ufunc_decls  = acc.ufunc_decls @ ec2.ufunc_decls; }
   in
@@ -2436,7 +2550,7 @@
     check_duplication ec;
     check_structure ec;
     check_allow_list ec;
-    (if not ep.header_only then check_priv_funcs ec);
+    (if not ep.header_only then check_priv_and_utility_funcs ec);
     if Plugin.available() then
       Plugin.gen_edge_routines ec ep
     else (
diff -Nur sdk/edger8r/linux/Lexer.mll sdk/edger8r/linux/Lexer.mll
--- sdk/edger8r/linux/Lexer.mll
+++ sdk/edger8r/linux/Lexer.mll
@@ -79,6 +79,9 @@
   | "struct"     { Tstruct }
   | "union"      { Tunion }
   | "enum"       { Tenum }
+  | "errno_list" { Terrno_list }
+  | "exception_handler" { Texception_handler }
+  | "utility_tcs" { Tutility }
 
   (* specifier *)
   | "enclave"    { Tenclave }
diff -Nur sdk/edger8r/linux/Parser.mly sdk/edger8r/linux/Parser.mly
--- sdk/edger8r/linux/Parser.mly
+++ sdk/edger8r/linux/Parser.mly
@@ -317,7 +317,7 @@
 %token Tchar Tshort Tunsigned Tint Tfloat Tdouble
        Tint8 Tint16 Tint32 Tint64
        Tuint8 Tuint16 Tuint32 Tuint64
-       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum
+       Tsizet Twchar Tvoid Tlong Tstruct Tunion Tenum Terrno_list Texception_handler Tutility
 %token Tenclave Tfrom Timport Ttrusted Tuntrusted Tallow Tpropagate_errno
 
 %start start_parsing
@@ -591,6 +591,19 @@
   | enum_definition                   { $1 }
   ;
 
+errno_list: Terrno_list TLBrace errno_list_body TRBrace {
+      { Ast.errnos = $3; }
+    }
+  ;
+
+errno_list_body: /* empty */ { [] }
+  | errno_list_eles          { List.rev $1 }
+  ;
+
+errno_list_eles: Tidentifier           { [$1] }
+  | errno_list_eles TComma Tidentifier { $3 :: $1 }
+  ;
+
 struct_member_list: struct_member_def TSemicolon    { [$1] }
   | struct_member_list struct_member_def TSemicolon { $2 :: $1 }
   ;
@@ -675,10 +688,20 @@
   | Tswitchless                      { true  }
   ;
 
+/* is_exception_handler? Default to false */
+exception_handler: /* nothing */ { false }
+  | Texception_handler           { true }
+  ;
+
+/* is_utility? Default to false */
+utility: /* nothing */ { false }
+  | Tutility           { true }
+  ;
+
 trusted_functions: /* nothing */          { [] }
-  | trusted_functions access_modifier func_def switchless_annotation TSemicolon {
-      check_ptr_attr $3 (symbol_start_pos(), symbol_end_pos());
-      Ast.Trusted { Ast.tf_fdecl = $3; Ast.tf_is_priv = $2; Ast.tf_is_switchless = $4 } :: $1
+  | trusted_functions utility exception_handler access_modifier func_def switchless_annotation TSemicolon {
+      check_ptr_attr $5 (symbol_start_pos(), symbol_end_pos());
+      Ast.Trusted { Ast.tf_fdecl = $5; Ast.tf_is_priv = $4; Ast.tf_is_switchless = $6; Ast.tf_is_exception_handler = $3; Ast.tf_is_utility = $2; } :: $1
     }
   ;
 
@@ -749,6 +772,7 @@
   | expressions include_declaration           { Ast.Include($2)   :: $1 }
   | expressions import_declaration TSemicolon { Ast.Importing($2) :: $1 }
   | expressions composite_defs TSemicolon     { Ast.Composite($2) :: $1 }
+  | expressions errno_list TSemicolon         { Ast.ErrnoList($2) :: $1 }
   | expressions enclave_functions             { Ast.Interface($2) :: $1 }
   ;
 
diff -Nur sdk/selib/sgx_create_report.cpp sdk/selib/sgx_create_report.cpp
--- sdk/selib/sgx_create_report.cpp
+++ sdk/selib/sgx_create_report.cpp
@@ -48,8 +48,6 @@
 // add a version to tservice.
 SGX_ACCESS_VERSION(tservice, 1)
 
-extern "C" void * __memset(void *dst, int c, size_t n);
-
 sgx_status_t sgx_create_report(const sgx_target_info_t *target_info, const sgx_report_data_t *report_data, sgx_report_t *report)
 {
     static_assert(sizeof(*target_info) == 512, "sgx_target_info_t");
@@ -57,11 +55,11 @@
     static_assert(sizeof(*report) == 432, "sgx_report_t");
 
     alignas(REPORT_DATA_ALIGN_SIZE) sgx_report_data_t tmp_report_data;
-    __memset((void *)&tmp_report_data, 0, sizeof(sgx_report_data_t));
+    memset((void *)&tmp_report_data, 0, sizeof(sgx_report_data_t));
     alignas(TARGET_INFO_ALIGN_SIZE) sgx_target_info_t tmp_target_info;
-    __memset((void *)&tmp_target_info, 0, sizeof(sgx_target_info_t));    
+    memset((void *)&tmp_target_info, 0, sizeof(sgx_target_info_t));
     alignas(REPORT_ALIGN_SIZE)sgx_report_t tmp_report;
-    __memset((void *)&tmp_report, 0, sizeof(sgx_report_t));
+    memset((void *)&tmp_report, 0, sizeof(sgx_report_t));
 
     // check parameters
     //
diff -Nur sdk/selib/sgx_get_key.cpp sdk/selib/sgx_get_key.cpp
--- sdk/selib/sgx_get_key.cpp
+++ sdk/selib/sgx_get_key.cpp
@@ -56,7 +56,6 @@
     size_t size = 0, buf_ptr = 0;
     sgx_key_request_t *tmp_key_request = NULL;
     sgx_key_128bit_t *tmp_key = NULL;
-    egetkey_status_t egetkey_status = EGETKEY_SUCCESS;
     int i = 0;
     const sgx_report_t *report = NULL;
     // check parameters
@@ -143,29 +142,7 @@
     memcpy_s(tmp_key_request, sizeof(*tmp_key_request), key_request, sizeof(*key_request));
 
     // Do EGETKEY
-    egetkey_status = (egetkey_status_t) do_egetkey(tmp_key_request, tmp_key);
-    switch(egetkey_status)
-    {
-    case EGETKEY_SUCCESS:
-        err = SGX_SUCCESS;
-        break;
-    case  EGETKEY_INVALID_ATTRIBUTE:
-        err =  SGX_ERROR_INVALID_ATTRIBUTE;
-        break;
-    case EGETKEY_INVALID_CPUSVN:
-        err =  SGX_ERROR_INVALID_CPUSVN;
-        break;
-    case EGETKEY_INVALID_ISVSVN:
-        err = SGX_ERROR_INVALID_ISVSVN;
-        break;
-    case EGETKEY_INVALID_KEYNAME:
-        err = SGX_ERROR_INVALID_KEYNAME;
-        break;
-    default:
-        err = SGX_ERROR_UNEXPECTED;
-        break;
-    }
-
+    err = egetkey_status_to_sgx_status(do_egetkey(tmp_key_request, tmp_key));
 
 CLEANUP:
     if((SGX_SUCCESS != err) && (NULL != key))
diff -Nur sdk/sign_tool/SignTool/manage_metadata.cpp sdk/sign_tool/SignTool/manage_metadata.cpp
--- sdk/sign_tool/SignTool/manage_metadata.cpp
+++ sdk/sign_tool/SignTool/manage_metadata.cpp
@@ -514,6 +514,7 @@
     if(m_rva == 0)
     {
         se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR);
+        se_trace(SE_TRACE_ERROR, "Sections size is 0\n");
         return false;
     }
 
@@ -616,7 +617,8 @@
     layout_t *layout_table = (layout_t *) alloc_buffer_from_metadata(size);
     if(layout_table == NULL)
     {
-        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR); 
+        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR);
+        se_trace(SE_TRACE_ERROR, "Layout table could not be allocated\n");
         return false;
     }
     m_metadata->dirs[DIR_LAYOUT].offset = (uint32_t)PTR_DIFF(layout_table, m_metadata);
@@ -858,7 +860,8 @@
     // tcs template
     if(false == build_tcs_template(tcs_template))
     {
-        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR); 
+        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR);
+        se_trace(SE_TRACE_ERROR, "Could not build TCS template\n");
         return false;
     }
     return true;
@@ -870,7 +873,8 @@
     patch_entry_t *patch_table = (patch_entry_t *) alloc_buffer_from_metadata(size);
     if(patch_table == NULL)
     {
-        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR); 
+        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR);
+        se_trace(SE_TRACE_ERROR, "Could not allocate patch table\n");
         return false;
     }
     m_metadata->dirs[DIR_PATCH].offset = (uint32_t)PTR_DIFF(patch_table, m_metadata);
@@ -901,7 +905,8 @@
     uint64_t rva = m_parser->get_symbol_rva("g_global_data");
     if(0 == rva)
     {
-        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR); 
+        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR);
+        se_trace(SE_TRACE_ERROR, "Could not find g_global_data\n");
          return false;
     }
 
@@ -915,7 +920,8 @@
     uint8_t *zero = (uint8_t *)alloc_buffer_from_metadata(0);  // get addr only, size will be determined later
     if(zero == NULL)
     {
-        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR); 
+        se_trace(SE_TRACE_ERROR, INVALID_ENCLAVE_ERROR);
+        se_trace(SE_TRACE_ERROR, "Could not allocate 0 bytes\n");
         return false;
     }
     bin_fmt_t bf = m_parser->get_bin_format();
diff -Nur sdk/sign_tool/SignTool/sign_tool.cpp sdk/sign_tool/SignTool/sign_tool.cpp
--- sdk/sign_tool/SignTool/sign_tool.cpp
+++ sdk/sign_tool/SignTool/sign_tool.cpp
@@ -101,7 +101,7 @@
 static int load_enclave(BinParser *parser, metadata_t *metadata)
 {
     std::unique_ptr<CLoader> ploader(new CLoader(const_cast<uint8_t *>(parser->get_start_addr()), *parser));
-    return ploader->load_enclave_ex(NULL, 0, metadata, NULL,  0, NULL);
+    return ploader->load_enclave_ex(NULL, 0, metadata, NULL, NULL, 0, NULL);
 }
 
 
diff -Nur sdk/simulation/driver_api/driver_api.cpp sdk/simulation/driver_api/driver_api.cpp
--- sdk/simulation/driver_api/driver_api.cpp
+++ sdk/simulation/driver_api/driver_api.cpp
@@ -67,6 +67,7 @@
     memset(&pinfo, 0, sizeof(pinfo));
     pinfo.src_page = secs;
     pinfo.sec_info = &sinfo;
+    pinfo.lin_addr = *start_addr;
 
     ce = reinterpret_cast<CEnclaveSim*>(DoECREATE_SW(&pinfo));
     if (ce == NULL) {
diff -Nur sdk/simulation/tinst/t_instructions.cpp sdk/simulation/tinst/t_instructions.cpp
--- sdk/simulation/tinst/t_instructions.cpp
+++ sdk/simulation/tinst/t_instructions.cpp
@@ -302,14 +302,21 @@
     tcs_t *tcs = GET_TCS_PTR(xdx);
     GP_ON(tcs == NULL);
 
-    // restore the used _tls_array
-    GP_ON(td_mngr_restore_td(tcs) == false);
-
     // check thread is in use or not
     tcs_sim_t *tcs_sim = reinterpret_cast<tcs_sim_t *>(tcs->reserved);
     GP_ON(tcs_sim->tcs_state != TCS_STATE_ACTIVE);
     tcs_sim->tcs_state = TCS_STATE_INACTIVE;
 
+    // restore the used _tls_array
+    // Restoring the TLS needs to happen after setting tcs state. Because Asylo
+    // signal handling relies on the TLS to decide whether or not to enter the
+    // enclave to handle the signal in simulation mode. If we set state after
+    // restoring the TLS, and a signal arrives in the window between them, it
+    // will enter the enclave to handle the signal since the TLS is restored to
+    // untrusted already, however the entry will be rejected as the tcs state is
+    // still active.
+    GP_ON(td_mngr_restore_td(tcs) == false);
+
     regs.xax = 0;
     regs.xbx = dest;
     regs.xcx = tcs_sim->saved_aep;
diff -Nur sdk/simulation/uae_service_sim/licensing_sim.cpp sdk/simulation/uae_service_sim/licensing_sim.cpp
--- sdk/simulation/uae_service_sim/licensing_sim.cpp
+++ sdk/simulation/uae_service_sim/licensing_sim.cpp
@@ -143,11 +143,6 @@
         return SGX_ERROR_INVALID_PARAMETER;
     }
 
-    if(((p_attribute->flags) & SGX_FLAGS_PROVISION_KEY) &&
-        memcmp(PVE_PUBLIC_KEY, &p_signature->key.modulus,
-        sizeof(PVE_PUBLIC_KEY)))
-        return SGX_ERROR_SERVICE_INVALID_PRIVILEGE;
-
     return get_launch_token_internal(p_signature,
         p_attribute,
         (token_t *)p_launch_token);
diff -Nur sdk/simulation/uinst/enclave_mngr.cpp sdk/simulation/uinst/enclave_mngr.cpp
--- sdk/simulation/uinst/enclave_mngr.cpp
+++ sdk/simulation/uinst/enclave_mngr.cpp
@@ -173,8 +173,8 @@
 // Note: this singleton implemenation is not multi-threading safe.
 CEnclaveMngr* CEnclaveMngr::get_instance()
 {
-    static CEnclaveMngr mngr;
-    return &mngr;
+    static CEnclaveMngr *mngr = new CEnclaveMngr;
+    return mngr;
 }
 
 // Use constructor attribute to make sure that the later calling of 
diff -Nur sdk/simulation/uinst/u_instructions.cpp sdk/simulation/uinst/u_instructions.cpp
--- sdk/simulation/uinst/u_instructions.cpp
+++ sdk/simulation/uinst/u_instructions.cpp
@@ -31,9 +31,16 @@
 
 
 // u_instructions.cpp -- It simulates Enclave instructions.
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+#include <vector>
+
+#include <pthread.h>
 #include <string.h>
 #include <assert.h>
 
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 
@@ -71,6 +78,121 @@
 
 #define mcp_same_size(dst_ptr, src_ptr, size) memcpy_s(dst_ptr, size, src_ptr, size)
 
+// A map that stores all the signal handlers registered prior to entering the
+// enclave.
+static std::unordered_map<int, std::unique_ptr<struct sigaction>>
+    *registered_signal_handlers =
+        new std::unordered_map<int, std::unique_ptr<struct sigaction>>;
+
+// A lock that protects |registered_signal_handlers| map.
+static std::mutex *registered_signal_handlers_lock = new std::mutex;
+
+// A map that stores the pthread ids with their corresponding tcs.
+static std::unordered_map<pthread_t, tcs_t *> *thread_to_tcs =
+    new std::unordered_map<pthread_t, tcs_t *>;
+
+// A lock that protects |thread_to_tcs| map.
+static std::mutex *thread_to_tcs_lock = new std::mutex;
+
+// If a signal arrives in simulation mode while the thread is running inside the
+// enclave, the handler does not have access to the thread local variables, as
+// the thread register is still pointing to the ones inside the enclave, this
+// handler resets the thread register to point to untrusted side before invoking
+// the registered signal handler, and sets it back after the signal is handled.
+static void switch_tls_and_handle_signal(int signum, siginfo_t *info, void *ucontext)
+{
+    tcs_t *tcs = NULL;
+    {
+        std::lock_guard<std::mutex> lock(*thread_to_tcs_lock);
+        auto it = thread_to_tcs->find(pthread_self());
+        if (it != thread_to_tcs->end())
+        {
+            tcs = it->second;
+            tcs_sim_t *tcs_sim = reinterpret_cast<tcs_sim_t *>(tcs->reserved);
+            // Restore untrusted TLS if the TCS is valid and active.
+            if (tcs_sim && tcs_sim->tcs_state == TCS_STATE_ACTIVE)
+            {
+                td_mngr_restore_td(tcs);
+            }
+        }
+    }
+
+    // Invoke the registered signal handler.
+    {
+        std::lock_guard<std::mutex> lock(*registered_signal_handlers_lock);
+        const auto it = registered_signal_handlers->find(signum);
+        if (it != registered_signal_handlers->end())
+        {
+            struct sigaction *act = it->second.get();
+            if ((!(act->sa_flags & SA_SIGINFO)) && act->sa_handler)
+            {
+                act->sa_handler(signum);
+            }
+            else if ((act->sa_flags & SA_SIGINFO) && act->sa_sigaction)
+            {
+                act->sa_sigaction(signum, info, ucontext);
+            }
+        }
+    }
+
+    if (tcs)
+    {
+        tcs_sim_t *tcs_sim = reinterpret_cast<tcs_sim_t *>(tcs->reserved);
+        // Set back to enclave TLS of the corresponding TCS if it's valid and
+        // active.
+        if (tcs_sim && tcs_sim->tcs_state == TCS_STATE_ACTIVE)
+        {
+            CEnclaveMngr *mngr = CEnclaveMngr::get_instance();
+            CEnclaveSim *ce = mngr->get_enclave(tcs);
+            secs_t *secs = ce->get_secs();
+            void *enclave_base_addr = secs->base;
+            td_mngr_set_td(enclave_base_addr, tcs);
+        }
+    }
+}
+
+// Register signal handlers to be invoked after switching thread register.
+static bool register_signal_handlers()
+{
+    std::vector<int> signals{SIGHUP, SIGINT, SIGQUIT, SIGTRAP, SIGILL, SIGABRT,
+        SIGBUS, SIGFPE, SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM,
+        SIGCHLD, SIGCONT, SIGSTOP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ,
+        SIGVTALRM, SIGWINCH, SIGSYS};
+    std::lock_guard<std::mutex> lock(*registered_signal_handlers_lock);
+    for (int signum : signals)
+    {
+        struct sigaction oldact;
+        if (sigaction(signum, /*act=*/NULL, &oldact) != 0)
+        {
+            return false;
+        }
+
+        // Stores the registered handler in |registered_signal_handlers| map,
+        // and registers |switch_tls_and_handle_signal| as the handler, which
+        // switches the thread register and invokes the registered handler.
+        if (registered_signal_handlers->find(signum)
+            == registered_signal_handlers->end())
+        {
+            if (((oldact.sa_flags & SA_SIGINFO) && oldact.sa_sigaction)
+                || ((!(oldact.sa_flags & SA_SIGINFO)) && oldact.sa_handler
+                    && oldact.sa_handler != SIG_DFL))
+            {
+                (*registered_signal_handlers)[signum] =
+                    std::unique_ptr<struct sigaction>(new struct sigaction(oldact));
+                struct sigaction act = {};
+                act.sa_flags = oldact.sa_flags;
+                act.sa_flags |= SA_SIGINFO;
+                act.sa_sigaction = &switch_tls_and_handle_signal;
+                if (sigaction(signum, &act, &oldact) != 0)
+                {
+                    return false;
+                }
+            }
+        }
+    }
+    return true;
+}
+
 uintptr_t _EINIT(secs_t* secs, enclave_css_t *css, token_t *launch)
 {
     CEnclaveMngr *mngr = CEnclaveMngr::get_instance();
@@ -129,6 +251,8 @@
         }
     }
 
+    GP_ON(register_signal_handlers() == false);
+
     // Mark it initialized
     this_secs->attributes.flags |= SGX_FLAGS_INITTED;
 
@@ -154,7 +278,7 @@
 
     // `ce' is not checked against NULL, since it is not
     // allocated with new(std::no_throw).
-    addr = se_virtual_alloc(NULL, (size_t)secs->size, MEM_COMMIT);
+    addr = se_virtual_alloc(pi->lin_addr, (size_t)secs->size, MEM_COMMIT);
     if (addr == NULL) {
         delete ce;
         return 0;
@@ -195,6 +319,11 @@
 
 uintptr_t _EREMOVE(const void *epc_lin_addr)
 {
+    {
+        std::lock_guard<std::mutex> lock(*thread_to_tcs_lock);
+        thread_to_tcs->clear();
+    }
+
     CEnclaveMngr *mngr = CEnclaveMngr::get_instance();
     CEnclaveSim *ce = mngr->get_enclave(epc_lin_addr);
 
@@ -235,11 +364,26 @@
         // Is TCS pointer page-aligned?
         GP_ON_EENTER(!IS_PAGE_ALIGNED(tcs));
 
+        // Mask all signals while holding/releasing locks to avoid deadlock,
+        // since enclave signal handling also enters the enclave here.
+        sigset_t mask;
+        sigfillset(&mask);
+        sigset_t old_mask;
+        sigprocmask(SIG_SETMASK, &mask, &old_mask);
+
+        {
+            std::lock_guard<std::mutex> lock(*thread_to_tcs_lock);
+            (*thread_to_tcs)[pthread_self()] = tcs;
+        }
+
         mngr = CEnclaveMngr::get_instance();
         assert(mngr != NULL);
 
-        // Is it really a TCS?
+        // Don't unmask signals after this point. Since get_enclave() also
+        // acquire locks.
         ce = mngr->get_enclave(tcs);
+
+        // Is it really a TCS?
         GP_ON_EENTER(ce == NULL);
         GP_ON_EENTER(!ce->is_tcs_page(tcs));
 
@@ -289,6 +433,7 @@
         regs.xsp = p_ssa_gpr->REG(sp_u);
         regs.xip = xip;
 
+        sigprocmask(SIG_SETMASK, &old_mask, nullptr);
         load_regs(&regs);
 
         // Returning from this function enters the enclave
diff -Nur sdk/simulation/urtssim/enclave_creator_sim.cpp sdk/simulation/urtssim/enclave_creator_sim.cpp
--- sdk/simulation/urtssim/enclave_creator_sim.cpp
+++ sdk/simulation/urtssim/enclave_creator_sim.cpp
@@ -230,7 +230,9 @@
     info.size = sizeof(system_features_t);
     info.version = SDK_VERSION_1_5;
     info.sealed_key = enclave->get_sealed_key();
-    status = enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info));
+    status =
+        enclave->ecall(ECMD_INIT_ENCLAVE, NULL, reinterpret_cast<void *>(&info),
+                       /*is_utility=*/false);
     //free the tcs used by initialization;
     enclave->get_thread_pool()->reset();
     if(SGX_SUCCESS == status)
@@ -239,7 +241,7 @@
     }
     else
     {
-        SE_TRACE(SE_TRACE_WARNING, "initialize enclave failed\n");
+        SE_TRACE(SE_TRACE_WARNING, "initialize enclave failed: 0x%0x\n", status);
         return SGX_ERROR_UNEXPECTED;
     }
 }
diff -Nur sdk/switchless/src/sl_siglines.c sdk/switchless/src/sl_siglines.c
--- sdk/switchless/src/sl_siglines.c
+++ sdk/switchless/src/sl_siglines.c
@@ -70,11 +70,12 @@
     uint64_t* free_lines = NULL;
     if (is_direction_sender(dir)) 
     {
+        uint32_t i = 0;
         free_lines = malloc(sizeof(uint64_t) * nlong);
         if (free_lines == NULL) 
             return -ENOMEM;
 		
-        for (uint32_t i = 0; i < nlong; i++) 
+        for (; i < nlong; i++) 
             free_lines[i] = (uint64_t)(-1);// 1's -> free
     }
     sglns->free_lines = free_lines;
diff -Nur sdk/switchless/src/sl_workers.c sdk/switchless/src/sl_workers.c
--- sdk/switchless/src/sl_workers.c
+++ sdk/switchless/src/sl_workers.c
@@ -69,11 +69,12 @@
     size_t table_size = sizeof(sl_fcall_table_t)
                       + sizeof(sl_fcall_func_t) * num_ecalls;
     sl_fcall_table_t* fcall_table = malloc(table_size);
+    uint32_t fi = 0;
     if (fcall_table == NULL) return NULL;
 
     fcall_table->ftb_size = num_ecalls;
 
-    for (uint32_t fi = 0; fi < num_ecalls; fi++) 
+    for (; fi < num_ecalls; fi++)
     {
         const ecall_info_t* ecall_info = &g_ecall_table.ecall_table[fi];
         fcall_table->ftb_func[fi] = ecall_info->is_priv == 0 ? (sl_fcall_func_t) ecall_info->ecall_addr : NULL;
diff -Nur sdk/tlibc/gen/spinlock.c sdk/tlibc/gen/spinlock.c
--- sdk/tlibc/gen/spinlock.c
+++ sdk/tlibc/gen/spinlock.c
@@ -31,10 +31,13 @@
 
 #include <sgx_spinlock.h>
 
-static inline void _mm_pause(void) __attribute__((always_inline));
+/* clang disallows defining builtin functions.
+ * GCC does allow defining alt_mm_pause as _mm_pause with -ffreestanding
+ */
+static inline void alt_mm_pause(void) __attribute__((always_inline));
 static inline int _InterlockedExchange(int volatile * dst, int val) __attribute__((always_inline));
 
-static inline void _mm_pause(void)  /* definition requires -ffreestanding */
+static inline void alt_mm_pause(void)
 {
     __asm __volatile(
         "pause"
@@ -63,7 +66,7 @@
     while(_InterlockedExchange((volatile int *)lock, 1) != 0) {
         while (*lock) {
             /* tell cpu we are spinning */
-            _mm_pause();
+            alt_mm_pause();
         } 
     }
 
diff -Nur sdk/tlibc/string/memset_s.c sdk/tlibc/string/memset_s.c
--- sdk/tlibc/string/memset_s.c
+++ sdk/tlibc/string/memset_s.c
@@ -38,6 +38,10 @@
 #include <stdint.h>
 #include <string.h>
 
+#ifndef _ERNNO_T_DEFINED
+typedef int errno_t;
+#endif
+
 /*
  * __memset_vp is a volatile pointer to a function.
  * It is initialised to point to memset, and should never be changed.
diff -Nur sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
--- sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
+++ sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp
@@ -35,6 +35,7 @@
 #include "se_tcrypto_common.h"
 #include "openssl/cmac.h"
 #include "openssl/err.h"
+#include "openssl/evp.h"
 
 /* Message Authentication - Rijndael 128 CMAC
 * Parameters:
diff -Nur sdk/trts/init_enclave.cpp sdk/trts/init_enclave.cpp
--- sdk/trts/init_enclave.cpp
+++ sdk/trts/init_enclave.cpp
@@ -50,13 +50,14 @@
 #include "trts_util.h"
 #include "se_memcpy.h"
 #include "se_cpu_feature.h"
+#include "runtime_support/rts_config.h"
 
 // The global cpu feature bits from uRTS
 uint64_t g_cpu_feature_indicator __attribute__((section(RELRO_SECTION_NAME))) = 0;
 int EDMM_supported __attribute__((section(RELRO_SECTION_NAME))) = 0;
 sdk_version_t g_sdk_version __attribute__((section(RELRO_SECTION_NAME))) = SDK_VERSION_1_5;
 
-const volatile global_data_t g_global_data __attribute__((section(".niprod"))) = {1, 2, 3, 4, 5, 6,
+const volatile global_data_t g_global_data __attribute__((section(".niprod"))) = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0, 0, 0}, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 0, {{{0, 0, 0, 0, 0, 0, 0}}}};
 uint32_t g_enclave_state __attribute__((section(".nipd"))) = ENCLAVE_INIT_NOT_STARTED;
 
@@ -202,17 +203,17 @@
     void *enclave_base = get_enclave_base();
     if(ENCLAVE_INIT_NOT_STARTED != lock_enclave())
     {
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_INVALID_STATE;
     }
     if(0 != init_enclave(enclave_base, ms))
     {
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_INVALID_PARAMETER;
     }
 
 #ifndef SE_SIM
-    if (SGX_SUCCESS != do_init_thread(tcs, true))
-    {
-        return SGX_ERROR_UNEXPECTED;
+    sgx_status_t ret = do_init_thread(tcs, true);
+    if (SGX_SUCCESS != ret) {
+        return ret;
     }
 
     /* for EDMM, we need to accept the trimming of the POST_REMOVE pages. */
@@ -227,7 +228,8 @@
     else
 #endif
     {
-        memset_s(GET_PTR(void, enclave_base, g_global_data.heap_offset), g_global_data.heap_size, 0, g_global_data.heap_size);
+      // memset_s(GET_PTR(void, enclave_base, g_global_data.heap_offset),
+      // g_global_data.heap_size, 0, g_global_data.heap_size);
     }
 
     g_enclave_state = ENCLAVE_INIT_DONE;
diff -Nur sdk/trts/linux/trts_pic.S sdk/trts/linux/trts_pic.S
--- sdk/trts/linux/trts_pic.S
+++ sdk/trts/linux/trts_pic.S
@@ -40,6 +40,11 @@
 
 #include "trts_pic.h"
 
+    /* .reserved */
+    .section .reserved_data, "aw",@progbits
+    .section .reserved_bss, "aw",@progbits
+    .section .reserved_heap, "aw",@progbits
+
     /* .text */
     .section .nipx,"ax",@progbits
 
diff -Nur sdk/trts/trts.cpp sdk/trts/trts.cpp
--- sdk/trts/trts.cpp
+++ sdk/trts/trts.cpp
@@ -39,6 +39,8 @@
 #include "global_data.h"
 #include "trts_internal.h"
 #include "internal/rts.h"
+#include "trts_util.h"
+#include "runtime_support/rts_config.h"
 
 #ifdef SE_SIM
 #include "t_instructions.h"    /* for `g_global_data_sim' */
@@ -318,6 +320,37 @@
     return 0;
 }
 
+void sgx_memory_layout(struct SgxMemoryLayout *memory_layout) {
+  get_memory_layout(memory_layout);
+}
+
+int sgx_active_entry_count() { return get_entry_count(); }
+
+int sgx_blocked_entry_count() { return get_blocked_entry_count(); }
+
+void sgx_block_entries() { set_block_entries(/*block=*/true); }
+
+void sgx_unblock_entries() { set_block_entries(/*block=*/false); }
+
+void sgx_reject_entries() { set_reject_entries(); }
+
+sgx_status_t egetkey_status_to_sgx_status(int egetkey_status) {
+  switch ((egetkey_status_t)egetkey_status) {
+    case EGETKEY_SUCCESS:
+      return SGX_SUCCESS;
+    case EGETKEY_INVALID_ATTRIBUTE:
+      return SGX_ERROR_INVALID_ATTRIBUTE;
+    case EGETKEY_INVALID_CPUSVN:
+      return SGX_ERROR_INVALID_CPUSVN;
+    case EGETKEY_INVALID_ISVSVN:
+      return SGX_ERROR_INVALID_ISVSVN;
+    case EGETKEY_INVALID_KEYNAME:
+      return SGX_ERROR_INVALID_KEYNAME;
+    default:
+      return SGX_ERROR_UNEXPECTED;
+  }
+}
+
 void random_stack_notify_gdb(void *addr, size_t size)
 {
     UNUSED(addr);
diff -Nur sdk/trts/trts_ecall.cpp sdk/trts/trts_ecall.cpp
--- sdk/trts/trts_ecall.cpp
+++ sdk/trts/trts_ecall.cpp
@@ -67,6 +67,11 @@
             return SGX_ERROR_ECALL_NOT_ALLOWED;
         return SGX_SUCCESS;
     }
+    // Exception handlers should be allowed no matter what ocall status it is.
+    if(g_ecall_table.ecall_table[ordinal].is_exception)
+    {
+        return SGX_SUCCESS;
+    }
     ocall_context_t *context = reinterpret_cast<ocall_context_t*>(thread_data->last_sp);
     if(context->ocall_flag != OCALL_FLAG)
     {
@@ -125,7 +130,7 @@
     *addr = const_cast<void *>(g_ecall_table.ecall_table[ordinal].ecall_addr);
     if(!sgx_is_within_enclave(*addr, 0))
     {
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_INVALID_STATE;
     }
 
     return SGX_SUCCESS;
@@ -344,7 +349,7 @@
 
     if(0 != GET_TLS_INFO(&__ImageBase, &tls_addr, &tdata_size))
     {
-        return SGX_ERROR_UNEXPECTED;
+        return SGX_ERROR_INVALID_PARAMETER;
     }
     if(tls_addr)
     {
@@ -355,7 +360,7 @@
     return SGX_SUCCESS;
 }
 
-sgx_status_t do_ecall(int index, void *ms, void *tcs)
+sgx_status_t do_ecall(int index, void *ms, void *tcs, bool interrupted)
 {
     sgx_status_t status = SGX_ERROR_UNEXPECTED;
     if(ENCLAVE_INIT_DONE != get_enclave_state())
@@ -363,7 +368,10 @@
         return status;
     }
     thread_data_t *thread_data = get_thread_data();
-    if( (NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy)))
+    // The thread local storage should not be cleared if this is a signal
+    // handling ecall that interrupts the original ecall.
+    if (!interrupted && ( (NULL == thread_data) ||
+         ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy))))
     {
         status = do_init_thread(tcs, false);
         if(0 != status)
diff -Nur sdk/trts/trts_internal.h sdk/trts/trts_internal.h
--- sdk/trts/trts_internal.h
+++ sdk/trts/trts_internal.h
@@ -40,6 +40,8 @@
 typedef struct {
     const void     *ecall_addr;
     uint8_t         is_priv;
+    uint8_t         is_exception;
+    uint8_t         is_utility;
 } ecall_addr_t;
 
 typedef struct {
@@ -66,7 +68,10 @@
 
 sgx_status_t do_init_thread(void *tcs, bool enclave_init);
 sgx_status_t do_init_enclave(void *ms, void *tcs) __attribute__((section(".nipx")));
-sgx_status_t do_ecall(int index, void *ms, void *tcs);
+// If |interrupted| is true, this is a user defined exception handler ecall
+// which interrupts the current running ecall, while trts_handle_exception deals
+// with the sgx defined exceptions.
+sgx_status_t do_ecall(int index, void *ms, void *tcs, bool interrupted);
 sgx_status_t do_oret(void *ms);
 sgx_status_t trts_handle_exception(void *tcs);
 sgx_status_t do_ecall_add_thread(void *ms);
diff -Nur sdk/trts/trts_nsp.cpp sdk/trts/trts_nsp.cpp
--- sdk/trts/trts_nsp.cpp
+++ sdk/trts/trts_nsp.cpp
@@ -46,30 +46,9 @@
 #include "thread_data.h"
 #include "global_data.h"
 #include "trts_internal.h"
+#include "trts_util.h"
 #include "internal/rts.h"
-
-static void init_stack_guard(void *tcs)
-{
-    thread_data_t *thread_data = get_thread_data();
-    if( (NULL == thread_data) || ((thread_data->stack_base_addr == thread_data->last_sp) && (0 != g_global_data.thread_policy)))
-    {
-         thread_data = GET_PTR(thread_data_t, tcs, g_global_data.td_template.self_addr);
-    }
-    else
-    {
-        return;
-    }
-
-    assert(thread_data != NULL);
-
-    size_t tmp_stack_guard = 0;
-    if (SGX_SUCCESS != sgx_read_rand(
-                (unsigned char*)&tmp_stack_guard,
-                sizeof(tmp_stack_guard)))
-        abort();
-
-    thread_data->stack_guard = tmp_stack_guard;
-}
+#include "sdk/trts/trts_nsp_internal.h"
 
 extern "C" int enter_enclave(int index, void *ms, void *tcs, int cssa) __attribute__((section(".nipx")));
 
@@ -87,13 +66,47 @@
         return error;
     }
 
-    if(cssa == 0)
+    // Increase the count if an ecall enters an enclave. The ocalls returning to
+    // the enclave shouldn't be counted in, since the ecall that invokes them is
+    // still active.
+    if (index != ECMD_ORET)
+    {
+        increase_entry_count();
+    }
+
+    // Check whether the incoming ecall is a user exception. If index is within
+    // range of the ecall table size, the is_exception field will be true for
+    // user exceptions.
+    uint8_t is_user_exception =
+        (index >= 0 && index < int(g_ecall_table.nr_ecall)) &&
+        g_ecall_table.ecall_table[index].is_exception;
+
+   // If enclave entries are blocked, wait till it's unblocked.
+    if (get_block_entries())
+    {
+        increase_blocked_entry_count();
+        while (get_block_entries()) {}
+        decrease_blocked_entry_count();
+    }
+
+    if (get_reject_entries())
+    {
+        error = SGX_ERROR_ECALL_NOT_ALLOWED;
+    }
+
+    // For a user exception, call |do_ecall| to enter enclave and handle the
+    // signal, in this case cssa could be 0 or 1 (which is likely to be 1 when
+    // an enclave is interrupted by an exception).
+    else if(cssa == 0 || (is_user_exception && cssa == 1))
     {
         if((index >= 0) || (index == ECMD_INIT_SWITCHLESS) || (index == ECMD_RUN_SWITCHLESS_TWORKER))
         {
             // Initialize stack guard if necessary
             init_stack_guard(tcs);
-            error = do_ecall(index, ms, tcs);
+            // If |cssa| is non-zero, this ecall is entering enclave as a user
+            // exception that interrupts the current running ecall.
+            bool is_interrupted = cssa != 0;
+            error = do_ecall(index, ms, tcs, is_interrupted);
         }
         else if(index == ECMD_INIT_ENCLAVE)
         {
@@ -124,5 +137,10 @@
     {
         set_enclave_state(ENCLAVE_CRASHED);
     }
+    // The ecall has finished and is leaving the enclave.
+    if (index != ECMD_ORET)
+    {
+        decrease_entry_count();
+    }
     return error;
 }
diff -Nur sdk/trts/trts_nsp_internal.cpp sdk/trts/trts_nsp_internal.cpp
--- sdk/trts/trts_nsp_internal.cpp
+++ sdk/trts/trts_nsp_internal.cpp
@@ -0,0 +1,29 @@
+#include "sdk/trts/trts_nsp_internal.h"
+
+#include <assert.h>
+#include <stddef.h>
+#include "global_data.h"
+#include "sgx_trts.h"
+#include "thread_data.h"
+#include "util.h"
+
+void init_stack_guard(void *tcs) {
+  thread_data_t *thread_data = get_thread_data();
+  if ((NULL == thread_data) ||
+      ((thread_data->stack_base_addr == thread_data->last_sp) &&
+       (0 != g_global_data.thread_policy))) {
+    thread_data =
+        GET_PTR(thread_data_t, tcs, g_global_data.td_template.self_addr);
+  } else {
+    return;
+  }
+
+  assert(thread_data != NULL);
+
+  size_t tmp_stack_guard = 0;
+  if (SGX_SUCCESS !=
+      sgx_read_rand((unsigned char *)&tmp_stack_guard, sizeof(tmp_stack_guard)))
+    abort();
+
+  thread_data->stack_guard = tmp_stack_guard;
+}
diff -Nur sdk/trts/trts_nsp_internal.h sdk/trts/trts_nsp_internal.h
--- sdk/trts/trts_nsp_internal.h
+++ sdk/trts/trts_nsp_internal.h
@@ -0,0 +1,6 @@
+#ifndef THIRD_PARTY_LINUX_SGX_SDK_TRTS_TRTS_NSP_H_
+#define THIRD_PARTY_LINUX_SGX_SDK_TRTS_TRTS_NSP_H_
+
+void init_stack_guard(void *tcs);
+
+#endif  // THIRD_PARTY_LINUX_SGX_SDK_TRTS_TRTS_NSP_H_
diff -Nur sdk/trts/trts_shared_constants.h sdk/trts/trts_shared_constants.h
--- sdk/trts/trts_shared_constants.h
+++ sdk/trts/trts_shared_constants.h
@@ -46,9 +46,7 @@
 #define RED_ZONE_SIZE   0
 #endif
 
-
-#define STATIC_STACK_SIZE   688
-
+#define STATIC_STACK_SIZE (8 * 1024)
 
 #endif
 
diff -Nur sdk/trts/trts_util.cpp sdk/trts/trts_util.cpp
--- sdk/trts/trts_util.cpp
+++ sdk/trts/trts_util.cpp
@@ -29,12 +29,51 @@
  *
  */
 
+#include <atomic>
 
 #include "trts_util.h"
 #include "global_data.h"
 #include "util.h"
 #include "thread_data.h"
 #include "trts_internal.h"
+#include "sgx_trts.h"
+
+// Number of active enclave entries.
+static std::atomic<int> entry_count(0);
+// Number of ocalls blocked from reentering the enclave.
+static std::atomic<int> blocked_entry_count(0);
+// The tcs that blocks other tcs from entering the enclave.
+static std::atomic<thread_data_t *> blocking_thread(0);
+// Reject all enclave entries if set to true.
+static std::atomic<bool> reject_entries(false);
+
+void increase_entry_count() { entry_count++; }
+void decrease_entry_count() { entry_count--; }
+int get_entry_count() { return entry_count; }
+
+void increase_blocked_entry_count() { blocked_entry_count++; }
+void decrease_blocked_entry_count() { blocked_entry_count--; }
+int get_blocked_entry_count() { return blocked_entry_count; }
+
+void set_block_entries(bool block)
+{
+    blocking_thread = block ? get_thread_data() : 0;
+}
+
+bool get_block_entries()
+{
+    return blocking_thread != 0 && get_thread_data() != blocking_thread;
+}
+
+void set_reject_entries()
+{
+    reject_entries = true;
+}
+
+bool get_reject_entries()
+{
+    return reject_entries;
+}
 
 // No need to check the state of enclave or thread.
 // The functions should be called within an ECALL, so the enclave and thread must be initialized at that time.
@@ -123,6 +162,51 @@
     return rsrv_size;
 }
 
+// A 1M bytes temporary storage buffer for data.
+static char reserved_data[1024 * 1024]
+    __attribute__((section(".reserved_data")));
+// A 1M bytes temporary storage buffer for bss.
+static char reserved_bss[1024 * 1024] __attribute__((section(".reserved_bss")));
+// A 1M bytes temporary storage buffer for heap.
+static char reserved_heap[1024 * 1024]
+    __attribute__((section(".reserved_heap")));
+
+void get_memory_layout(struct SgxMemoryLayout *memory_layout) {
+  // Enclave base and size.
+  memory_layout->base = get_enclave_base();
+  memory_layout->size = get_enclave_size();
+
+  // Enclave initialized data/uninitialized data/heap.
+  memory_layout->data_base =
+      GET_PTR(void, &__ImageBase, g_global_data.data_offset);
+  memory_layout->data_size = static_cast<size_t>(g_global_data.data_size);
+  memory_layout->bss_base =
+      GET_PTR(void, &__ImageBase, g_global_data.bss_offset);
+  memory_layout->bss_size = static_cast<size_t>(g_global_data.bss_size);
+  memory_layout->heap_base = get_heap_base();
+  memory_layout->heap_size = get_heap_size();
+
+  // Current tcs thread data/stack.
+  thread_data_t *thread_data = get_thread_data();
+  memory_layout->thread_base = reinterpret_cast<void *>(thread_data);
+  memory_layout->thread_size = sizeof(thread_data_t);
+  memory_layout->stack_base = reinterpret_cast<void *>(
+      thread_data->stack_base_addr);
+  memory_layout->stack_limit =
+      reinterpret_cast<void *>(thread_data->stack_limit_addr);
+
+  // Temporary storage data buffer section.
+  memory_layout->reserved_data_base = reinterpret_cast<void *>(reserved_data);
+  memory_layout->reserved_data_size = sizeof(reserved_data);
+
+  // Temporary storage bss buffer section.
+  memory_layout->reserved_bss_base = reinterpret_cast<void *>(reserved_bss);
+  memory_layout->reserved_bss_size = sizeof(reserved_bss);
+
+  // Temporary storage heap buffer section.
+  memory_layout->reserved_heap_base = reinterpret_cast<void *>(reserved_heap);
+  memory_layout->reserved_heap_size = sizeof(reserved_heap);}
+
 int * get_errno_addr(void)
 {
     thread_data_t *thread_data = get_thread_data();
@@ -179,4 +263,3 @@
     return ( !(sp & (sizeof(uintptr_t) - 1))   // sp is expected to be 4/8 bytes aligned
            && is_stack_addr((void*)sp, 0) );   // sp points to the top/bottom of stack are accepted
 }
-
diff -Nur sdk/trts/trts_util.h sdk/trts/trts_util.h
--- sdk/trts/trts_util.h
+++ sdk/trts/trts_util.h
@@ -36,6 +36,7 @@
 #include <stddef.h>    /* for size_t */
 #include <stdbool.h>
 #include "se_types.h"
+#include "sgx_trts.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -50,6 +51,17 @@
 size_t get_rsrv_end(void);
 size_t get_rsrv_size(void);
 size_t get_rsrv_min_size(void);
+void get_memory_layout(struct SgxMemoryLayout *memory_layout);
+void increase_entry_count();
+void decrease_entry_count();
+int get_entry_count();
+void increase_blocked_entry_count();
+void decrease_blocked_entry_count();
+int get_blocked_entry_count();
+void set_block_entries(bool block);
+bool get_block_entries();
+void set_reject_entries();
+bool get_reject_entries();
 int * get_errno_addr(void);
 bool is_stack_addr(void *address, size_t size);
 bool is_valid_sp(uintptr_t sp);
diff -Nur sdk/trts/trts_veh.cpp sdk/trts/trts_veh.cpp
--- sdk/trts/trts_veh.cpp
+++ sdk/trts/trts_veh.cpp
@@ -49,6 +49,7 @@
 #include "util.h"
 #include "trts_util.h"
 #include "trts_shared_constants.h"
+#include "se_cdefs.h"
 
 
 typedef struct _handler_node_t
diff -Nur /dev/null BUILD
--- /dev/null
+++ BUILD
@@ -0,0 +1,1341 @@
+# linux-sgx is the Intel SGX SDK
+
+load(":sgx_sdk.bzl", "asylo_sgx_backend", "enclave_lds", "sgx")
+load("@rules_cc//cc:defs.bzl", "cc_binary", "cc_library")
+load("@rules_proto//proto:defs.bzl", "proto_library")
+load("@rules_cc//cc:defs.bzl", "cc_proto_library")
+
+# "notice" licenses present:
+# BSD (Intel SGX SDK, libunwind, libcxxrt),
+# NetBSD, FreeBSD, OpenBSD
+# zlib/libpng (Tinyxml)
+# UIUC (LLVM's compiler_rt library)
+# Apache v2 (EPID SDK and Asylo additions)
+# STLPort
+# OpenSSL/SSLeay* (OpenSSL),
+
+# "reciprocal" licenses mentioned but unused:
+# Eclipse public license 1.0 (SGX Eclipse plugin)
+
+# "restricted" licenses present:
+# GPLv2 (ittnotify)
+
+# "restricted" licenses mentioned but unused:
+# Intel (precompiled signed enclaves),
+# Intel sample code license (rdrand)
+
+# "unencumbered" licenses present:
+# SQLite
+# CC0 1.0 (DLMalloc),
+licenses(["reciprocal"])  # Eclipse public license
+
+exports_files([
+    "License.txt",
+    "enclave.lds.tpl",
+    "enclave_test_private.pem",
+    "sgx_sdk.bzl",
+])
+
+config_setting(
+    name = "dbg",
+    values = {
+        "compilation_mode": "dbg",
+    },
+    visibility = ["//visibility:public"],
+)
+
+enclave_lds(
+    name = "enclave_lds",
+    debug = select({
+        ":dbg": True,
+        "//conditions:default": False,
+    }),
+    simulation = select({
+        ":sgx_sim": True,
+        "//conditions:default": False,
+    }),
+    visibility = [
+        "//visibility:public",
+    ],
+)
+
+sgx.full_enclave_configuration(
+    name = "enclave_debug_config",
+    disable_debug = "0",
+    heap_max_size = "0x2000000",
+    isvextprodid = "",
+    isvfamilyid = "",
+    isvsvn = "0",
+    kss = False,
+    misc_mask = "0xffffffff",
+    misc_select = "0",
+    prodid = "0",
+    provision_key = "0",
+    stack_max_size = "0x40000",
+    # 2 tcs are reserved by the framework, 10 are left for users.
+    tcs_num = "12",
+    tcs_policy = "0",
+    visibility = ["//visibility:public"],
+)
+
+cc_library(
+    name = "urts",
+    hdrs = ["include/sgx_urts.h"],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":untrusted_inc",
+        ":urts_select",
+    ],
+)
+
+cc_library(
+    name = "public",
+    hdrs = [
+        "include/global_data.h",
+        "include/se_memcpy.h",
+        "include/sgx_cpuid.h",
+        "include/sgx_edger8r.h",
+        "include/sgx_eid.h",
+        "include/sgx_error.h",
+        "include/sgx_key.h",
+        "include/sgx_lfence.h",
+        "include/sgx_quote.h",
+        "include/sgx_report.h",
+        "include/sgx_thread.h",
+        "include/sgx_tseal.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "sgx_runtime_support",
+    srcs = [
+        "runtime_support/sgx_init_crypto_lib.c",
+        "runtime_support/sgx_init_string_lib.c",
+        "sdk/compiler-rt/stack_chk.c",
+        "sdk/tlibc/string/consttime_memequal.c",
+        "sdk/tlibc/string/memset_s.c",
+    ],
+    hdrs = ["runtime_support/rts_config.h"],
+    deps = [":common_inc"],
+)
+
+# A non-versioned, publicly-consumable target for the UAE service.
+cc_library(
+    name = "uae_service",
+    hdrs = ["include/sgx_uae_service.h"],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":uae_service_select",
+    ],
+)
+
+proto_library(
+    name = "ipc_common_proto_cc",
+    srcs = ["psw/ae/aesm_service/source/core/ipc/messages.proto"],
+)
+
+cc_proto_library(
+    name = "ipc_common_proto_cc_cc_proto",
+    deps = [":ipc_common_proto_cc"],
+)
+
+SL_COMMON_SRCS = [
+    "common/src/sl_fcall_mngr_common.c",
+    "common/src/sl_siglines_common.c",
+]
+
+RTS_COMMON_SRCS = [
+    "common/src/linux/xsave_gnu.S",
+]
+
+SL_COMMON_HDRS = [
+    # Headers for switchless calls that must be copied to reinterpret with or
+    # without -DSL_INSIDE_ENCLAVE.
+    "common/inc/internal/sl_uswitchless.h",
+    "common/inc/internal/sl_workers.h",
+    "common/inc/internal/sl_fcall_mngr.h",
+    "common/inc/internal/sl_fcall_mngr_common.h",  # depends of sl_fcall_mngr.h
+    "common/inc/internal/sl_debug.h",
+    "common/inc/internal/sl_siglines.h",
+]
+
+RTS_COMMON_TEXTUAL_HDRS = [
+    "common/inc/internal/linux/sgx_cet.h",
+    "common/inc/internal/linux/linux-regs.h",  # included as ASM
+]
+
+URTS_COMMON_SRCS = RTS_COMMON_SRCS + [
+    "common/src/sgx_memset_s.cpp",
+    "psw/urts/cpu_features.cpp",
+    "psw/urts/cpu_features_ext.cpp",
+    "psw/urts/enclave.cpp",
+    "psw/urts/enclave_mutex.cpp",
+    "psw/urts/launch_checker.cpp",
+    "psw/urts/linux/debugger_support.cpp",
+    "psw/urts/linux/enter_enclave.S",
+    "psw/urts/linux/get_thread_id.cpp",
+    "psw/urts/linux/misc.cpp",
+    "psw/urts/linux/sig_handler.cpp",
+    "psw/urts/linux/urts.cpp",
+    "psw/urts/linux/urts_emodpr.cpp",
+    "psw/urts/linux/urts_internal.cpp",
+    "psw/urts/linux/urts_trim.cpp",
+    "psw/urts/loader.cpp",
+    "psw/urts/node.cpp",
+    "psw/urts/parser/elf32parser.cpp",
+    "psw/urts/parser/elf64parser.cpp",
+    "psw/urts/parser/parserfactory.cpp",
+    "psw/urts/parser/section.cpp",
+    "psw/urts/prd_css_util.cpp",
+    "psw/urts/routine.cpp",
+    "psw/urts/se_detect.cpp",
+    "psw/urts/se_ocalls.cpp",
+    "psw/urts/tcs.cpp",
+    "psw/urts/urts_version.cpp",
+    "psw/urts/urts_xsave.cpp",
+]
+
+URTS_COMMON_HDRS = [
+    "common/inc/internal/enclave_creator.h",
+    "psw/urts/cpu_features.h",
+    "psw/urts/create_param.h",
+    "psw/urts/enclave.h",
+    "psw/urts/enclave_creator_hw.h",
+    "psw/urts/file.h",
+    "psw/urts/launch_checker.h",
+    "psw/urts/linux/debugger_support.h",
+    "psw/urts/linux/read_xcr0.h",
+    "psw/urts/linux/sig_handler.h",
+    "psw/urts/linux/urts_emodpr.h",
+    "psw/urts/linux/urts_trim.h",
+    "psw/urts/loader.h",
+    "psw/urts/node.h",
+    "psw/urts/parser/binparser.h",
+    "psw/urts/parser/elf32parser.h",
+    "psw/urts/parser/elf64parser.h",
+    "psw/urts/parser/parserfactory.h",
+    "psw/urts/parser/section.h",
+    "psw/urts/prd_css_util.h",
+    "psw/urts/se_detect.h",
+    "psw/urts/section_info.h",
+    "psw/urts/tcs.h",
+]
+
+URTS_COMMON_TEXTUAL_HDRS = RTS_COMMON_TEXTUAL_HDRS + [
+    "psw/urts/parser/clearvars.h",
+    "psw/urts/linux/enter_enclave.h",
+    "psw/urts/parser/elfparser.h",
+    "psw/urts/parser/elfparser.cpp",
+    "psw/urts/parser/update_global_data.hxx",
+    "psw/urts/urts_com.h",
+]
+
+PSW_COMMON_SRCS = glob(["psw/ae/aesm_service/source/core/ipc/*.cpp"]) + [
+    "psw/enclave_common/sgx_enclave_common.cpp",
+    "psw/uae_service/uae_wrapper/src/AEServicesImpl.cpp",
+    "psw/uae_service/uae_wrapper/src/AEServicesProvider.cpp",
+    "psw/uae_service/uae_wrapper/src/tae_ocall_api.cpp",
+    "psw/uae_service/uae_wrapper/src/uae_api.cpp",
+    "psw/uae_service/uae_service_assert.cpp",
+    "psw/uae_service/uae_service_version.cpp",
+    "psw/urts/linux/edmm_utility.cpp",
+]
+
+PSW_COMMON_HDRS = glob([
+    "psw/ae/aesm_service/source/core/ipc/*.h",
+]) + [
+    "psw/ae/aesm_service/source/common/platform_info_blob.h",
+    "psw/enclave_common/sgx_enclave_common.h",
+    "common/inc/sgx_uae_service.h",
+    "psw/uae_service/uae_wrapper/inc/AEServices.h",
+    "psw/uae_service/config.h",
+    "psw/uae_service/uae_wrapper/inc/AEServicesImpl.h",
+    "psw/uae_service/uae_wrapper/inc/AEServicesProvider.h",
+    "psw/ae/inc/aeerror.h",
+    "psw/ae/inc/byte_order.h",
+    "psw/ae/inc/se_sig_rl.h",
+    "psw/urts/linux/edmm_utility.h",
+    "psw/urts/linux/isgx_user.h",
+]
+
+PSW_COMMON_INCLUDES = [
+    "-Iexternal/sgx_dcap/QuoteGeneration/quote_wrapper/common/inc",
+    "-Iexternal/sgx_dcap/QuoteGeneration/pce_wrapper/inc",
+    "-Iexternal/linux_sgx/psw/ae/aesm_service/source/common",
+    "-Iexternal/linux_sgx/psw/ae/aesm_service/source/core/ipc",
+    "-Iexternal/linux_sgx/psw/uae_service/uae_wrapper/inc",
+    "-Iexternal/linux_sgx/psw/ae/inc",
+    "-Iexternal/linux_sgx/psw/ae/inc/internal",
+    "-Iexternal/linux_sgx/psw/ae/aesm_service/source",
+]
+
+cc_library(
+    name = "se_wrapper",
+    srcs = [
+        "common/src/se_event.c",
+        "common/src/se_map.c",
+        "common/src/se_memory.c",
+        "common/src/se_rwlock.c",
+        "common/src/se_thread.c",
+        "common/src/se_time.c",
+        "common/src/se_trace.c",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc_internal",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "uae_service_hw",
+    srcs = PSW_COMMON_SRCS + [
+        "psw/uae_service/sgx_uae_service.cpp",
+        "psw/ae/aesm_service/source/bundles/ecdsa_quote_service_bundle/ecdsa_quote_service_bundle.cpp",
+        "psw/ae/aesm_service/source/common/aesm_logic.h",
+        "psw/ae/aesm_service/source/common/event_strings.h",
+        "psw/ae/aesm_service/source/common/oal/aesm_persistent_storage.h",
+        "psw/ae/aesm_service/source/common/oal/aesm_thread.h",
+        "psw/ae/aesm_service/source/common/oal/error_report.h",
+        "psw/ae/aesm_service/source/common/oal/internal_log.h",
+        "psw/ae/aesm_service/source/common/oal/oal.h",
+        "psw/ae/aesm_service/source/common/oal/power.h",
+        "psw/ae/aesm_service/source/interfaces/get_att_key_id.h",
+        "psw/ae/aesm_service/source/interfaces/quote_ex_service.h",
+        "psw/ae/aesm_service/source/interfaces/quote_provider_service.h",
+        "psw/ae/aesm_service/source/interfaces/quote_proxy_service.h",
+        "psw/ae/aesm_service/source/interfaces/select_att_key_id.h",
+        "psw/ae/aesm_service/source/interfaces/service.h",
+        "psw/ae/aesm_service/source/interfaces/pce_service.h",
+        "psw/ae/data/constants/linux/default_url_info.hh",
+        "psw/ae/inc/internal/tlv_common.h",
+    ],
+    hdrs = PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/psw/ae/aesm_service/source/interfaces",
+        "-Iexternal/linux_sgx/psw/ae/inc",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/data/constants/linux",
+        "-Iexternal/linux_sgx/psw/enclave_common",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/boringssl",
+        "-Wno-deprecated-declarations",
+        "-Wno-unused-function",
+        "-Wno-missing-braces",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+        "-Wl,--export-dynamic",
+        "-lrt",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_epid",
+        ":ipc_common_proto_cc_cc_proto",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        "@sgx_dcap//:quote_wrapper",
+        "@sgx_dcap//:quote_wrapper_common",
+    ],
+)
+
+cc_library(
+    name = "urts_hw",
+    srcs = URTS_COMMON_SRCS + [
+        "psw/urts/enclave_creator_hw_com.cpp",
+        "psw/urts/linux/enclave_creator_hw.cpp",
+    ],
+    hdrs = URTS_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DElfParser=Elf64Parser",
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/psw/enclave_common",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    textual_hdrs = URTS_COMMON_TEXTUAL_HDRS + [
+        "common/inc/internal/se_lock.hpp",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_epid",
+        ":external_ittnotify",
+        ":ipc_common_proto_cc_cc_proto",
+        ":psw_switchless",
+        ":rts_common",
+        ":se_wrapper",
+        ":uae_service_hw",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "external_ittnotify",
+    srcs = [
+        "external/vtune/linux/include/legacy/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/disable_warnings.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_static.c",
+    ],
+    hdrs = [
+        "external/vtune/linux/include/ittnotify.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_config.h",
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_types.h",
+    ],
+    copts = [
+        "-DITT_ARCH_IA64",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+    ],
+    textual_hdrs = [
+        "external/vtune/linux/sdk/src/ittnotify/ittnotify_static.h",
+    ],
+)
+
+cc_library(
+    name = "external_tinyxml2",
+    srcs = ["external/tinyxml2/tinyxml2.cpp"],
+    hdrs = ["external/tinyxml2/tinyxml2.h"],
+    copts = [
+        "-Wno-implicit-fallthrough",
+        "-Iexternal/linux_sgx/external/tinyxml2",
+    ],
+)
+
+cc_binary(
+    name = "sgx_sign_tool",
+    srcs = [
+        "sdk/sign_tool/SignTool/elf_helper.h",
+        "sdk/sign_tool/SignTool/enclave_creator_sign.cpp",
+        "sdk/sign_tool/SignTool/enclave_creator_sign.h",
+        "sdk/sign_tool/SignTool/manage_metadata.cpp",
+        "sdk/sign_tool/SignTool/manage_metadata.h",
+        "sdk/sign_tool/SignTool/parse_key_file.cpp",
+        "sdk/sign_tool/SignTool/parse_key_file.h",
+        "sdk/sign_tool/SignTool/sign_tool.cpp",
+        "sdk/sign_tool/SignTool/util_st.cpp",
+        "sdk/sign_tool/SignTool/util_st.h",
+    ],
+    copts = [
+        "-Wno-sign-compare",
+        "-fpie",
+        "-Iexternal/linux_sgx/external/tinyxml2",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/sign_tool/SignTool",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/boringssl",
+    ],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_tinyxml2",
+        ":untrusted_inc_internal",
+        ":urts_select",
+        "@boringssl//:crypto",
+    ],
+)
+
+# trts_nsp uses a function that must be compiled without the stack protector
+# transformation. There is no way in clang to disable it on a per-function
+# basis, so its implementation is moved to this library.
+cc_library(
+    name = "trts_nsp_internal",
+    srcs = ["sdk/trts/trts_nsp_internal.cpp"],
+    hdrs = ["sdk/trts/trts_nsp_internal.h"],
+    copts = [
+        "-fno-stack-protector",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc_internal",
+        ":trusted_inc",
+    ],
+)
+
+TRTS_COMMON_SRCS = RTS_COMMON_SRCS + [
+    "sdk/selib/sgx_create_report.cpp",
+    "sdk/selib/tservice_version.cpp",
+    "sdk/trts/init_enclave.cpp",
+    "sdk/trts/init_optimized_lib.cpp",
+    "sdk/trts/linux/elf_parser.c",
+    "sdk/trts/linux/global_init.c",
+    "sdk/trts/linux/metadata_sec.S",
+    "sdk/trts/linux/tls_support.c",
+    "sdk/trts/linux/trts_pic.S",
+    #    "sdk/trts/linux/x86_64/setcontext.S",
+    "sdk/trts/trts.cpp",
+    "sdk/trts/trts_add_trim.cpp",
+    "sdk/trts/trts_ecall.cpp",
+    "sdk/trts/trts_emodpr.cpp",
+    "sdk/trts/trts_nsp.cpp",
+    "sdk/trts/trts_ocall.cpp",
+    "sdk/trts/trts_switchless.cpp",
+    "sdk/trts/trts_trim.cpp",
+    "sdk/trts/trts_util.cpp",
+    "sdk/trts/trts_veh.cpp",
+    "sdk/trts/trts_version.cpp",
+    "sdk/trts/trts_xsave.cpp",
+]
+
+TRTS_COMMON_HDRS = [
+    "sdk/cpprt/linux/libunwind/src/x86_64/ucontext_i.h",
+    "sdk/trts/init_optimized_lib.h",
+    "sdk/trts/linux/elf_parser.h",
+    "sdk/trts/trts_emodpr.h",
+    "sdk/trts/trts_trim.h",
+    "sdk/trts/trts_util.h",
+]
+
+TRTS_COMMON_TEXTUAL_HDRS = RTS_COMMON_TEXTUAL_HDRS + ["sdk/trts/linux/trts_pic.h"]
+
+cc_library(
+    name = "trts_common",
+    hdrs = [
+        "sdk/trts/trts_internal.h",
+        "sdk/trts/trts_shared_constants.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc_internal",
+        ":trts_switchless",
+    ],
+)
+
+cc_library(
+    name = "trts_hw",
+    srcs = TRTS_COMMON_SRCS + TRTS_COMMON_HDRS,
+    copts = [
+        "-DISE=1",
+        "-D__NR_rt_sigprocmask=0",  # Provided just for parse_headers
+        "-D__linux__",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+    ],
+    features = ["pic"],
+    linkopts = [
+        "-Wl,--no-as-needed",
+    ],
+    linkstatic = 1,
+    textual_hdrs = TRTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":rts_common",
+        ":sgx_runtime_support",
+        ":sgx_spin_lock",
+        ":trts_common",
+        ":trts_nsp_internal",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        ":trusted_random_buffers",
+        "@boringssl//:crypto",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "trts_switchless",
+    srcs = SL_COMMON_SRCS + SL_COMMON_HDRS + [
+        "sdk/switchless/src/sgx_ocall_switchless.c",
+        "sdk/switchless/src/sl_fcall_mngr.c",
+        "sdk/switchless/src/sl_init.c",
+        "sdk/switchless/src/sl_memlog.c",
+        "sdk/switchless/src/sl_once.c",
+        "sdk/switchless/src/sl_printk.c",
+        "sdk/switchless/src/sl_siglines.c",
+        "sdk/switchless/src/sl_workers.c",
+    ],
+    copts = [
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "trts_sim",
+    srcs = TRTS_COMMON_SRCS + TRTS_COMMON_HDRS + [
+        "sdk/selib/sgx_get_key.cpp",
+        "sdk/selib/sgx_verify_report.cpp",
+        "sdk/tseal/tSeal_internal.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-DISE=1",
+        "-D__NR_rt_sigprocmask=0",  # Provided just for parse_headers
+        "-D__linux__",
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts",
+        "-Iexternal/linux_sgx/sdk/tseal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/cpprt/linux/libunwind/src/x86_64",
+    ],
+    features = ["pic"],
+    linkstatic = 1,
+    textual_hdrs = TRTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+        ":sgx_spin_lock",
+        ":sgx_tcrypto",
+        ":tinst_sim",
+        ":trts_common",
+        ":trts_nsp_internal",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        ":trusted_random_buffers",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "rts_common",
+    srcs = [
+        "common/src/crypto_cmac_128.cpp",
+        "common/src/crypto_evp_digest.cpp",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    features = ["pic"],
+    deps = [
+        ":common_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "sim_common",
+    srcs = [
+        "sdk/simulation/assembly/linux/lowlib.S",
+        "sdk/simulation/uinst/linux/restore_tls.c",
+    ],
+    hdrs = [
+        "sdk/simulation/assembly/linux/gnu_tls.h",
+        "sdk/simulation/assembly/lowlib.h",
+        "sdk/simulation/tinst/deriv.h",
+        "sdk/simulation/tinst/rts_sim.h",
+        "sdk/simulation/uinst/td_mngr.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed",
+    ],
+    linkstatic = 1,
+    textual_hdrs = RTS_COMMON_TEXTUAL_HDRS,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":rts_common",
+    ],
+)
+
+cc_library(
+    name = "tinst_sim",
+    srcs = [
+        "sdk/simulation/tinst/deriv.cpp",
+        "sdk/simulation/tinst/t_instructions.cpp",
+    ],
+    hdrs = [
+        "sdk/simulation/tinst/t_instructions.h",
+    ],
+    copts = [
+        "-DSE_SIM=1",
+        "-fno-rtti",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sim_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "external_rdrand",
+    srcs = [
+        "external/rdrand/src/config.h",
+        "external/rdrand/src/rdrand.c",
+        "external/rdrand/src/rdrand.h",
+    ],
+    hdrs = ["external/rdrand/rdrand.h"],
+    copts = [
+        "-Iexternal/linux_sgx/external/rdrand/src",
+        "-Wno-maybe-uninitialized",
+    ],
+)
+
+cc_library(
+    name = "uae_service_sim",
+    srcs = PSW_COMMON_SRCS + [
+        "common/src/sgx_read_rand.cpp",
+        "psw/ae/common/se_sig_rl.cpp",
+        "sdk/simulation/uae_service_sim/licensing_sim.cpp",
+        "sdk/simulation/uae_service_sim/linux/platform_service_sim.cpp",
+        "sdk/simulation/uae_service_sim/platform_service_sim_com.cpp",
+        "sdk/simulation/uae_service_sim/quoting_sim.cpp",
+        "sdk/simulation/uae_service_sim/uae_service_sim.h",
+        "sdk/simulation/urtssim/cpusvn_util.h",
+        "sdk/simulation/urtssim/cpusvn_util.cpp",
+    ],
+    hdrs = PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DSE_SIM=1",
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/external/rdrand",
+        "-Iexternal/linux_sgx/psw/enclave_common",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/uae_service_sim",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/linux_sgx/sdk/tseal",
+        "-Wno-deprecated-declarations",
+    ],
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+        "-Wl,--export-dynamic",
+        "-lrt",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_epid",
+        ":external_rdrand",
+        ":ipc_common_proto_cc_cc_proto",
+        ":pse_types",
+        ":sim_common",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        "@sgx_dcap//:quote_wrapper_common",
+    ],
+)
+
+# Target selecting either simulation mode or hardware mode includes for the UAE
+# service library based on the value of SGX_SIM.
+cc_library(
+    name = "uae_service_select",
+    hdrs = PSW_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":ipc_common_proto_cc_cc_proto",
+        ":common_inc",
+        ":common_inc_internal",
+        ":se_wrapper",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":external_epid",
+    ] + select({
+        "//conditions:default": [":uae_service_sim"],
+        ":sgx_hw": [":uae_service_hw"],
+    }),
+)
+
+cc_library(
+    name = "pse_types",
+    hdrs = [
+        "psw/ae/inc/internal/pse_types.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "psw_switchless",
+    srcs = SL_COMMON_SRCS + SL_COMMON_HDRS + [
+        "psw/uswitchless/sgx_ecall_switchless_untrusted.c",
+        "psw/uswitchless/sl_fcall_mngr_untrusted.c",
+        "psw/uswitchless/sl_siglines_untrusted.c",
+        "psw/uswitchless/sl_uswitchless_untrusted.c",
+        "psw/uswitchless/sl_workers_untrusted.c",
+    ],
+    copts = ["-Iexternal/linux_sgx/common/inc/internal"],
+    features = ["pic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "urts_sim",
+    srcs = URTS_COMMON_SRCS + [
+        "sdk/simulation/assembly/linux/sgxsim.S",
+        "sdk/simulation/assembly/sgxsim.h",
+        "sdk/simulation/driver_api/driver_api.cpp",
+        "sdk/simulation/uinst/enclave_mngr.cpp",
+        "sdk/simulation/uinst/enclave_mngr.h",
+        "sdk/simulation/uinst/linux/get_tcs.c",
+        "sdk/simulation/uinst/linux/set_tls.c",
+        "sdk/simulation/uinst/u_instructions.cpp",
+        "sdk/simulation/uinst/u_instructions.h",
+        "sdk/simulation/urtssim/cpusvn_util.cpp",
+        "sdk/simulation/urtssim/cpusvn_util.h",
+        "sdk/simulation/urtssim/enclave_creator_sim.cpp",
+        "sdk/simulation/urtssim/enclave_creator_sim.h",
+        "sdk/simulation/urtssim/urts_sim.h",
+    ],
+    hdrs = URTS_COMMON_HDRS,
+    copts = PSW_COMMON_INCLUDES + [
+        "-DSE_SIM=1",
+        "-DElfParser=Elf64Parser",
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/external/vtune/linux/include",
+        "-Iexternal/linux_sgx/external/vtune/linux/sdk/src/ittnotify",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/boringssl",
+    ],
+    features = ["pic"],  # Not trusted, but Intel's Makefile has -fPIC
+    linkopts = [
+        "-Wl,--no-as-needed -ldl",
+    ],
+    linkstatic = 1,
+    textual_hdrs = URTS_COMMON_TEXTUAL_HDRS + [
+        "sdk/simulation/assembly/linux/sw_emu.h",  # included as ASM
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_epid",
+        ":external_ittnotify",
+        ":ipc_common_proto_cc_cc_proto",
+        ":pse_types",
+        ":psw_switchless",
+        ":se_wrapper",
+        ":sim_common",
+        ":uae_service_sim",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+)
+
+# The headers that are common across trusted and untrusted targets.
+cc_library(
+    name = "common_inc",
+    hdrs = [
+        "common/inc/sgx.h",
+        "common/inc/sgx_attributes.h",
+        "common/inc/sgx_cpuid.h",
+        "common/inc/sgx_defs.h",
+        "common/inc/sgx_dh.h",
+        "common/inc/sgx_ecp_types.h",
+        "common/inc/sgx_edger8r.h",
+        "common/inc/sgx_eid.h",
+        "common/inc/sgx_error.h",
+        "common/inc/sgx_key.h",
+        "common/inc/sgx_key_exchange.h",
+        "common/inc/sgx_lfence.h",
+        "common/inc/sgx_quote.h",
+        "common/inc/sgx_report.h",
+        "common/inc/sgx_tae_service.h",
+        "common/inc/sgx_tcrypto.h",
+        "common/inc/sgx_thread.h",
+        "common/inc/sgx_tseal.h",
+        "common/inc/sgx_uswitchless.h",
+    ],
+    includes = [
+        "common/inc",
+    ],
+    visibility = ["@sgx_dcap//:__pkg__"],
+)
+
+cc_library(
+    name = "untrusted_inc",
+    hdrs = [
+        "common/inc/sgx_urts.h",
+    ],
+    visibility = ["@sgx_dcap//:__pkg__"],
+    deps = [":common_inc"],
+)
+
+cc_library(
+    name = "common_inc_internal",
+    srcs = [
+        "common/src/sl_memlog_common.c",
+        "common/src/sl_once_common.c",
+    ],
+    hdrs = [
+        "common/inc/internal/arch.h",
+        "common/inc/internal/cpputil.h",
+        "common/inc/internal/cpuid.h",
+        "common/inc/internal/crypto_wrapper.h",
+        "common/inc/internal/elf_util.h",
+        "common/inc/internal/elfheader/elf_common.h",
+        "common/inc/internal/elfheader/elfstructs.h",
+        "common/inc/internal/global_data.h",
+        "common/inc/internal/linux/cpuid_gnu.h",
+        "common/inc/internal/metadata.h",
+        "common/inc/internal/mini_snprintf.h",
+        "common/inc/internal/routine.h",
+        "common/inc/internal/rts.h",
+        "common/inc/internal/rts_cmd.h",
+        "common/inc/internal/se_cdefs.h",
+        "common/inc/internal/se_cpu_feature_defs.h",
+        "common/inc/internal/se_cpu_feature_defs_ext.h",
+        "common/inc/internal/se_error_internal.h",
+        "common/inc/internal/se_macro.h",
+        "common/inc/internal/se_memcpy.h",
+        "common/inc/internal/se_page_attr.h",
+        "common/inc/internal/se_quote_internal.h",
+        "common/inc/internal/se_stdio.h",
+        "common/inc/internal/se_string.h",
+        "common/inc/internal/se_types.h",
+        "common/inc/internal/se_version.h",
+        "common/inc/internal/sgx_memset_s.h",
+        "common/inc/internal/sl_atomic.h",
+        "common/inc/internal/sl_bitops.h",
+        "common/inc/internal/sl_compiler.h",
+        "common/inc/internal/sl_init.h",
+        "common/inc/internal/sl_memlog.h",
+        "common/inc/internal/sl_once.h",
+        "common/inc/internal/sl_printk.h",
+        "common/inc/internal/sl_spinlock.h",
+        "common/inc/internal/sl_types.h",
+        "common/inc/internal/sl_util.h",
+        "common/inc/internal/thread_data.h",
+        "common/inc/internal/uncopyable.h",
+        "common/inc/internal/uswitchless.h",
+        "common/inc/internal/util.h",
+        "common/inc/internal/xsave.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        # common/inc/internal cannot be included via "includes" since
+        # __cpuid gets overwritten with an incompatible definition from
+        # the usual cpuid.h header file.
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    textual_hdrs = [
+        "common/inc/internal/inst.h",
+    ],
+    deps = [
+        ":common_inc",
+        ":external_epid",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "untrusted_inc_internal",
+    hdrs = [
+        "common/inc/internal/driver_api.h",
+        "common/inc/internal/oal/uae_oal_api.h",
+        "common/inc/internal/se_atomic.h",
+        "common/inc/internal/se_debugger_lib.h",
+        "common/inc/internal/se_event.h",
+        "common/inc/internal/se_lock.hpp",
+        "common/inc/internal/se_map.h",
+        "common/inc/internal/se_memory.h",
+        "common/inc/internal/se_rwlock.h",
+        "common/inc/internal/se_string.h",
+        "common/inc/internal/se_thread.h",
+        "common/inc/internal/se_time.h",
+        "common/inc/internal/se_trace.h",
+        "common/inc/internal/se_vendor.h",
+        "common/inc/internal/se_wrapper.h",
+        "common/inc/internal/sgx_read_rand.h",
+        "common/inc/internal/uae_service_internal.h",
+        "psw/ae/inc/internal/aesm_error.h",
+        "psw/ae/inc/internal/epid_pve_type.h",
+        "psw/ae/inc/internal/pce_cert.h",
+    ],
+    copts = [
+        "-DSL_INSIDE_ENCLAVE",
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/boringssl",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_epid",
+        ":untrusted_inc",
+        "@boringssl//:crypto",
+        "@sgx_dcap//:quote_wrapper_common",
+    ],
+)
+
+cc_library(
+    name = "external_epid",
+    hdrs = [
+        "external/epid-sdk/epid/common/bitsupplier.h",
+        "external/epid-sdk/epid/common/epiddefs.h",
+        "external/epid-sdk/epid/common/errors.h",
+        "external/epid-sdk/epid/common/types.h",
+        "external/epid-sdk/epid/member/api.h",
+    ],
+    copts = ["-Iexternal/linux_sgx/external/epid-sdk"],
+)
+
+# Target selecting either simulation or hardware mode untrusted include files
+# based on the value of SGX_SIM.
+cc_library(
+    name = "urts_select",
+    # Reprovide untrusted_inc's header to avoid layering violation.
+    hdrs = URTS_COMMON_HDRS,
+    copts = [
+        "-Wa,--noexecstack",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/common/inc/internal/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/psw/urts",
+        "-Iexternal/linux_sgx/psw/urts/linux",
+        "-Iexternal/linux_sgx/psw/urts/parser",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly",
+        "-Iexternal/linux_sgx/sdk/simulation/assembly/linux",
+        "-Iexternal/linux_sgx/sdk/simulation/tinst",
+        "-Iexternal/linux_sgx/sdk/simulation/uinst",
+        "-Iexternal/linux_sgx/sdk/simulation/urtssim",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",
+        "-Iexternal/linux_sgx/psw/ae/inc",
+        "-Iexternal/boringssl",
+    ],
+    deps = [
+        ":common_inc",
+        ":untrusted_inc",
+        ":untrusted_inc_internal",
+        ":common_inc_internal",
+        ":uae_service_select",
+    ] + select({
+        ":sgx_hw": [":urts_hw"],
+        "//conditions:default": [
+            ":urts_sim",
+        ],
+    }),
+)
+
+# The following targets are designed with to be built with the Asylo toolchain.
+cc_library(
+    name = "trusted_inc",
+    srcs = [
+        "sdk/tlibc/gen/se_cpuid.c",
+    ],
+    hdrs = [
+        "common/inc/sgx_trts.h",
+        "common/inc/sgx_trts_exception.h",
+        "common/inc/sgx_utils.h",
+    ],
+    copts = [
+        "-ffreestanding",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ],
+    deps = [
+        ":common_inc",
+        ":sgx_runtime_support",
+        ":sgx_spin_lock",
+    ],
+)
+
+cc_library(
+    name = "trusted_random_buffers",
+    hdrs = ["common/inc/sgx_random_buffers.h"],
+    copts = [
+        "-Wno-vla",
+        "-Iexternal/linux_sgx/common/inc/internal",
+    ] + select(
+        {
+            ":sgx_hw": ["-mrdrand"],
+            ":sgx_sim": ["-DSE_SIM=1"],
+        },
+        no_match_error = "Expected to be built in either SGX hardware- or simulation mode",
+    ),
+    deps = [
+        ":common_inc_internal",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "trusted_inc_internal",
+    hdrs = [
+        "common/inc/internal/cpprt_internal.h",
+        "common/inc/internal/ecp_interface.h",
+        "common/inc/internal/global_init.h",
+        "common/inc/internal/pcl_common.h",
+        "common/inc/internal/se_cpu_feature.h",
+        "common/inc/internal/se_enclave_type.h",
+        "common/inc/internal/se_tcrypto_common.h",
+        "common/inc/internal/sgx_ecc256_internal.h",
+        "common/inc/internal/sgx_profile.h",
+        "common/inc/internal/sgx_sha256_128.h",
+        "common/inc/internal/ssl_wrapper.h",
+        "common/inc/internal/tae_service_internal.h",
+        "common/inc/internal/trts_inst.h",
+        "common/inc/internal/tseal_migration_attr.h",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/external/epid-sdk",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/trts/",
+        "-Iexternal/linux_sgx/psw/ae/inc/internal",  # bad layering for pse_types
+        "-Iexternal/boringssl",
+    ],
+    linkopts = ["-Wl,--export-dynamic"],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":external_epid",
+        ":pse_types",
+        ":sgx_runtime_support",
+        ":sgx_spin_lock",
+        ":trusted_inc",
+        "@boringssl//:crypto",
+    ],
+)
+
+cc_library(
+    name = "sgx_tthread",
+    srcs = [
+        "sdk/tlibthread/sethread_cond.cpp",
+        "sdk/tlibthread/sethread_internal.h",
+        "sdk/tlibthread/sethread_mutex.cpp",
+        "sdk/tlibthread/sethread_utils.cpp",
+    ],
+    copts = [
+        "-g -O0",
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto",
+        "-Iexternal/linux_sgx/sdk/trts",
+    ],
+    linkstatic = 1,
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_spin_lock",
+        ":trts_common",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+    ],
+)
+
+cc_library(
+    name = "sgx_tcrypto",
+    srcs = [
+        "sdk/tlibcrypto/sgxssl/sgx_cmac128.cpp",
+        "sdk/tlibcrypto/tcrypto_version.cpp",
+    ],
+    copts = [
+        "-Iexternal/linux_sgx/common/inc/internal",
+        "-Iexternal/linux_sgx/sdk/tlibcrypto",
+        "-DUSE_SGXSSL",
+        "-Iexternal/boringssl",
+    ],
+    linkopts = [
+        "-Wl,--export-dynamic",
+    ],
+    deps = [
+        ":common_inc",
+        ":common_inc_internal",
+        ":sgx_runtime_support",
+        ":trusted_inc",
+        ":trusted_inc_internal",
+        "@boringssl//:crypto",
+    ],
+    alwayslink = 1,
+)
+
+cc_library(
+    name = "sgx_spin_lock",
+    srcs = ["sdk/tlibc/gen/spinlock.c"],
+    hdrs = ["common/inc/sgx_spinlock.h"],
+    deps = [":common_inc"],
+)
+
+cc_library(
+    name = "debug_key_mrsigner",
+    testonly = 1,
+    srcs = ["debug_key_mrsigner.cc"],
+    hdrs = ["debug_key_mrsigner.h"],
+    visibility = ["//visibility:public"],
+)
+
+# Target selecting either simulation or hardware mode trusted include files
+# based on the value of SGX_SIM.
+cc_library(
+    name = "trts",
+    hdrs = [
+        "include/sgx.h",
+        "include/sgx_trts.h",
+        "include/sgx_trts_exception.h",
+    ],
+    tags = [
+        "manual",
+    ],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":common_inc",
+        ":trusted_inc",
+    ] + select(
+        {
+            ":sgx_hw": [":trts_hw"],
+            ":sgx_sim": [":trts_sim"],
+        },
+        no_match_error = "Expected to be built in either SGX hardware- or simulation mode",
+    ),
+)
+
+# The edger8r tool uses an language unsupported by Bazel, so call ocamlbuild
+# in a genrule. (sudo apt-get install ocaml)
+filegroup(
+    name = "edger8r_srcs",
+    srcs = [
+        "sdk/edger8r/linux/Ast.ml",
+        "sdk/edger8r/linux/CodeGen.ml",
+        "sdk/edger8r/linux/Edger8r.ml",
+        "sdk/edger8r/linux/Lexer.mll",
+        "sdk/edger8r/linux/Parser.mly",
+        "sdk/edger8r/linux/Plugin.ml",
+        "sdk/edger8r/linux/Preprocessor.ml",
+        "sdk/edger8r/linux/SimpleStack.ml",
+        "sdk/edger8r/linux/Util.ml",
+    ],
+)
+
+genrule(
+    name = "sgx_edger8r",
+    srcs = [":edger8r_srcs"],
+    outs = ["sgx_edger8r_binary"],
+    cmd = "OUT=`pwd`/$(@); " +
+          "BUILD=`mktemp -d`; " +
+          "LOCS=($(locations :edger8r_srcs)); " +
+          "cd $$(dirname \"$${LOCS[0]}\"); " +
+          # Call ocamlbuild directly instead of make since the default
+          # build directory can get permission denied on mkdir.
+          "ocamlbuild -libs str,unix -build-dir $$BUILD Edger8r.native > /dev/null; " +
+          "cp $$BUILD/Edger8r.native $$OUT",
+    executable = True,
+    output_to_bindir = True,
+    visibility = ["//visibility:public"],
+)
+
+# These configuration settings are used to select build configurations based
+# on if building for hardware or simulation sgx enclaves.
+#   sgx_hw matches --config=sgx, which adds:
+#                                --define="ASYLO_SGX=1"
+#                                --define="SGX_SIM=0"
+#   sgx_sim matches --config=sgx-sim, which adds:
+#                                     --define="ASYLO_SGX=1"
+#                                     --define="SGX_SIM=1"
+#   sgx matches sgx_hw and sgx_sim
+# ASYLO_SGX implies that the build uses either SGX backend (hardware or simulation).
+# By default enclave launching applications will support simulation enclaves.
+# You can manually specify "bazel build --define="SGX_SIM=1" :mytarget" to
+# support hardware enclaves.
+asylo_sgx_backend(
+    name = "asylo_sgx_hw",
+    visibility = [
+        "//visibility:public",
+    ],
+)
+
+asylo_sgx_backend(
+    name = "asylo_sgx_sim",
+    visibility = [
+        "//visibility:public",
+    ],
+)
+
+config_setting(
+    name = "sgx_hw",
+    values = {
+        "define": "SGX_SIM=0",
+    },
+    visibility = ["//visibility:public"],
+)
+
+config_setting(
+    name = "sgx_sim",
+    values = {
+        "define": "SGX_SIM=1",
+    },
+    visibility = ["//visibility:public"],
+)
diff -Nur /dev/null sgx_sdk.bzl
--- /dev/null
+++ sgx_sdk.bzl
@@ -0,0 +1,997 @@
+"""Build tools for supporting Intel's SDK."""
+
+load("@com_google_asylo_backend_provider//:enclave_info.bzl", "backend_tools")
+load("@com_google_asylo_backend_provider//:transitions.bzl", "transitions")
+
+# website-docs-metadata
+# ---
+#
+# title: "@linux_sgx//:sgx_sdk.bzl"
+#
+# overview: Build rules for defining SGX enclaves.
+#
+# location: /_docs/reference/api/bazel/sgx_sdk_bzl.md
+#
+# layout: docs
+#
+# type: markdown
+#
+# toc: true
+#
+# ---
+# {% include home.html %}
+
+SGXEnclaveInfo = provider(
+    doc = ("A provider attached to an SGX enclave target for compile-time " +
+           "type-checking purposes"),
+)
+
+# Documentation is duplicated between the provider and the rule that populates
+# the provider
+_config_fields = {
+    "disable_debug": ("Indicates whether launching the enclave in debug " +
+                      "mode is disabled"),
+    "heap_max_size": "The enclave's maximum heap size in bytes (4KB aligned)",
+    "isvsvn": ("The enclave's ISV (Independent Software Vendor) assigned " +
+               "Security Version Number"),
+    "misc_mask": "A mask indicating which bits in misc_select are enforced",
+    "misc_select": "The desired Extended SSA frame feature (must be 0)",
+    "prodid": ("The enclave's ISV (Independent Software Vendor) assigned " +
+               "Product ID"),
+    "provision_key": ("Indicates whether the enclave has access to the " +
+                      "Provisioning Key and the Provisioning Seal Key"),
+    "kss": ("A boolean that indicates whether the enclave can use Key " +
+            "Sharing and Separation (KSS)"),
+    "isvextprodid": ("The enclave's 16-byte extended ISVPRODID value. It is an " +
+                     "error to set this attribute if 'kss' is set to False"),
+    "isvfamilyid": ("The enclave's 16-byte extended ISV Family ID. It is an " +
+                    "error to set this attribute if 'kss' is set to False"),
+    "stack_max_size": "The enclave's maximum stack size in bytes (4KB aligned)",
+    "tcs_num": ("The number of Thread Control Structures allocated for " +
+                "the enclave"),
+    "tcs_policy": ("The TCS management policy (" +
+                   "0 - The TCS is bound to the untrusted thread, " +
+                   "1 - The TCS is unbound to the untrusted thread)"),
+}
+
+SGXEnclaveConfigInfo = provider(
+    doc = "Stores an enclave configuration for enclave signing",
+    fields = _config_fields,
+)
+SGXSigstructInfo = provider(
+    doc = ("A provider on enclave signing material that carries the enclave " +
+           "and configuration targets that generate it."),
+    fields = {
+        "config": ("An SGXEnclaveConfigInfo provider that represents the " +
+                   "configuration options"),
+        "unsigned": "A cc_unsigned_enclave in an SGX backend",
+    },
+)
+
+_hw_backend_label = "@linux_sgx//:asylo_sgx_hw"
+_sim_backend_label = "@linux_sgx//:asylo_sgx_sim"
+SGX_BACKEND_LABELS = {
+    _hw_backend_label: backend_tools.all_labels[_hw_backend_label],
+    _sim_backend_label: backend_tools.all_labels[_sim_backend_label],
+}
+
+def _enclave_lds_impl(ctx):
+    output = ctx.actions.declare_file("enclave.lds")
+    ctx.actions.expand_template(
+        template = ctx.file._template,
+        output = output,
+        substitutions = {
+            "{g_global_data_sim}": "g_global_data_sim;" if ctx.attr.simulation else "",
+            "{g_peak_heap_used}": "g_peak_heap_used;" if ctx.attr.debug else "",
+        },
+    )
+    linking_context = cc_common.create_linking_context(
+        additional_inputs = [output],
+        user_link_flags = ["-Wl,--version-script", output.path],
+    )
+    return [DefaultInfo(files = depset([output])), CcInfo(linking_context = linking_context)]
+
+enclave_lds = rule(
+    implementation = _enclave_lds_impl,
+    doc = "Creates a version script to limit enclave symbol visibility",
+    attrs = {
+        "simulation": attr.bool(mandatory = True),
+        "debug": attr.bool(mandatory = True),
+        "_template": attr.label(default = "@linux_sgx//:enclave.lds.tpl", allow_single_file = True),
+    },
+)
+
+def _sgx_cc_unsigned_enclave_impl(ctx):
+    if not ctx.attr.linkshared:
+        fail("linkshared must be nonzero")
+    if not ctx.attr.linkstatic:
+        fail("linkstatic must be nonzero")
+    providers = backend_tools.cc_binary(
+        ctx,
+        basename = ctx.label.name.replace(".so", ""),
+        extra_features = ["fully_static_link", "pie"],
+        extra_copts = ["-fstack-protector"],
+        extra_linkopts = [
+            "-Wl,-Bstatic",
+            "-Wl,-Bsymbolic",
+            "-Wl,-pie,-eenclave_entry",
+            "-Wl,--defsym,__ImageBase=0",
+            "-Wl,--export-dynamic",
+        ],
+        extra_linking_contexts = [ctx.attr._lds[CcInfo].linking_context],
+    )
+    return providers + [SGXEnclaveInfo(), backend_tools.EnclaveInfo()]
+
+_transition_dict = {
+    "backend": attr.label(
+        mandatory = True,
+        providers = [backend_tools.AsyloBackendInfo],
+    ),
+    "_whitelist_function_transition": attr.label(
+        default = "//tools/whitelists/function_transition_whitelist",
+    ),
+}
+
+def _make_sgx_cc_unsigned_enclave(transition):
+    return rule(
+        doc = "Defines a C++ unsigned enclave in an SGX backend",
+        implementation = _sgx_cc_unsigned_enclave_impl,
+        cfg = transitions.toolchain if transition else None,
+        attrs = backend_tools.merge_dicts(backend_tools.cc_binary_attrs(), {
+            "_lds": attr.label(
+                default = "@linux_sgx//:enclave_lds",
+                allow_single_file = True,
+            ),
+        }, _transition_dict if transition else {}),
+        fragments = ["cpp"],
+    )
+
+_sgx_cc_unsigned_enclave = _make_sgx_cc_unsigned_enclave(
+    transition = False,
+)
+
+_sgx_cc_unsigned_enclave_transition = None
+
+def sgx_unsigned_enclave(
+        name,
+        stamp = 0,
+        backends = SGX_BACKEND_LABELS,
+        name_by_backend = {},
+        **kwargs):
+    """Build rule for creating a C++ unsigned SGX enclave shared object file.
+
+    Args:
+      name: The enclave target name.
+      stamp: The cc_binary stamp argument, but with a default value 0.
+      backends: The Asylo backend labels to build with (:asylo_sgx_sim and/or
+          :asylo_sgx_hw)
+      name_by_backend: A dict from backend label to enclave target name.
+          Optional.
+      **kwargs: cc_binary arguments.
+    """
+    if not transitions.supported(native.package_name()):
+        tags = kwargs.pop("tags", []) + ["asylo-cfh"]
+        _sgx_cc_unsigned_enclave(
+            name = name,
+            stamp = not (not stamp),
+            tags = tags,
+            **kwargs
+        )
+    else:
+        kwargs = backend_tools.merge_dicts(
+            kwargs,
+            {
+                "stamp": stamp,
+                "tags": kwargs.get("tags", []) + ["asylo-transition"],
+            },
+        )
+        backend_tools.all_backends(
+            rule_or_macro = _sgx_cc_unsigned_enclave_transition,
+            name = name,
+            backends = backends,
+            name_by_backend = name_by_backend,
+            kwargs = kwargs,
+        )
+
+def _validate_kss_attribute(attribute, attribute_name, kss):
+    "Validates a 16-byte hex-encoded KSS attribute."
+    if attribute == "":
+        return
+
+    if not attribute.startswith("0x"):
+        fail("Value must start with 0x", attribute_name)
+
+    ascii_hex = "0123456789abcdefABCDEF"
+    for i in range(2, len(attribute)):
+        if attribute[i] not in ascii_hex:
+            fail("Value must be a hex-encoded value", attribute_name)
+
+    # Max length of 32 hex characters with '0x' prefix.
+    if len(attribute) > 34:
+        fail("Hex-encoded value cannot exceed 16 bytes", attribute_name)
+
+    if attribute != "" and not kss:
+        fail("Must enable KSS to set {} attribute".format(attribute_name.upper()), attribute_name)
+
+def _kss_attribute_xml_tag(attribute, attribute_name_upper):
+    "Creates a valid or empty XML tag for a valid or empty KSS attribute."
+    if attribute == "":
+        return attribute
+
+    padding_size = 34 - len(attribute)
+    attribute = "0" * padding_size + attribute[2:]
+
+    return "\n".join([
+        "  <{}_L>0x{}</{}_L>".format(attribute_name_upper, attribute[16:], attribute_name_upper),
+        "  <{}_H>0x{}</{}_H>".format(attribute_name_upper, attribute[0:16], attribute_name_upper),
+    ])
+
+def _sgx_full_enclave_configuration_impl(ctx):
+    """Implementation of enclave signing configuration file formatting."""
+    xml_file = ctx.actions.declare_file(ctx.label.name + ".xml")
+
+    # Let base be None if there is no base.
+    base = ctx.attr.base and ctx.attr.base[SGXEnclaveConfigInfo]
+    config = SGXEnclaveConfigInfo(
+        prodid = ctx.attr.prodid or (base and base.prodid),
+        isvsvn = ctx.attr.isvsvn or (base and base.isvsvn),
+        stack_max_size = ctx.attr.stack_max_size or (base and base.stack_max_size),
+        heap_max_size = ctx.attr.heap_max_size or (base and base.heap_max_size),
+        tcs_num = ctx.attr.tcs_num or (base and base.tcs_num),
+        tcs_policy = ctx.attr.tcs_policy or (base and base.tcs_policy),
+        disable_debug = ctx.attr.disable_debug or (base and base.disable_debug),
+        provision_key = ctx.attr.provision_key or (base and base.provision_key),
+        # False is falsy yet also what we want to use instead of None.
+        kss = ctx.attr.kss if ctx.attr.kss != None else (base and base.kss),
+        # The "" default value is Falsy, so None must be explicitly tested.
+        isvfamilyid = ctx.attr.isvfamilyid if ctx.attr.isvfamilyid != None else (base and base.isvfamilyid),
+        isvextprodid = ctx.attr.isvextprodid if ctx.attr.isvextprodid != None else (base and base.isvextprodid),
+        misc_select = ctx.attr.misc_select or (base and base.misc_select),
+        misc_mask = ctx.attr.misc_mask or (base and base.misc_mask),
+    )
+
+    if config.prodid == None:
+        fail("prodid must be specified")
+    if config.isvsvn == None:
+        fail("isvsvn must be specified")
+    if config.stack_max_size == None:
+        fail("stack_max_size must be specified")
+    if config.heap_max_size == None:
+        fail("heap_max_size must be specified")
+    if config.tcs_num == None:
+        fail("tcs_num must be specified")
+    if config.tcs_policy == None:
+        fail("tcs_poly must be specified")
+    if config.disable_debug == None:
+        fail("disable_debug must be specified")
+    if config.kss == None:
+        fail("kss must be specified")
+    if config.isvfamilyid == None:
+        fail("isvfamilyid must be specified")
+    if config.isvextprodid == None:
+        fail("isvextprodid must be specified")
+    if config.misc_select == None:
+        fail("misc_select must be specified")
+    if config.misc_mask == None:
+        fail("misc_mask must be specified")
+
+    _validate_kss_attribute(config.isvfamilyid, "isvfamilyid", config.kss)
+    _validate_kss_attribute(config.isvextprodid, "isvextprodid", config.kss)
+
+    content = "\n".join([
+        "<EnclaveConfiguration>",
+        "  <ProdID>%s</ProdID>" % config.prodid,
+        "  <ISVSVN>%s</ISVSVN>" % config.isvsvn,
+        "  <StackMaxSize>%s</StackMaxSize>" % config.stack_max_size,
+        "  <HeapMaxSize>%s</HeapMaxSize>" % config.heap_max_size,
+        "  <TCSNum>%s</TCSNum>" % config.tcs_num,
+        "  <TCSPolicy>%s</TCSPolicy>" % config.tcs_policy,
+        "  <DisableDebug>%s</DisableDebug>" % config.disable_debug,
+        "  <ProvisionKey>%s</ProvisionKey>" % config.provision_key,
+        "  <EnableKSS>%s</EnableKSS>" % ("1" if config.kss else "0"),
+        _kss_attribute_xml_tag(config.isvfamilyid, "ISVFAMILYID"),
+        _kss_attribute_xml_tag(config.isvextprodid, "ISVEXTPRODID"),
+        "  <MiscSelect>%s</MiscSelect>" % config.misc_select,
+        "  <MiscMask>%s</MiscMask>" % config.misc_mask,
+        "</EnclaveConfiguration>",
+    ])
+
+    # Strip any empty lines created by optional attributes that do not have
+    # default values.
+    content = [line for line in content.split("\n") if line.strip() != ""]
+
+    ctx.actions.write(
+        output = xml_file,
+        content = "\n".join(content) + "\n",  # Ensure \n at file end.
+    )
+    return [DefaultInfo(files = depset([xml_file]), data_runfiles = ctx.runfiles([xml_file])), config]
+
+sgx_full_enclave_configuration = rule(
+    implementation = _sgx_full_enclave_configuration_impl,
+    doc = ("Defines an enclave configuration that is meant to be used as " +
+           "base configuration. Use sgx_enclave_configuration to get a " +
+           "sensible default base."),
+    attrs = {
+        "base": attr.label(
+            doc = ("An initial configuration from which to derive. Base " +
+                   "configuration fields may be overwritten by setting " +
+                   "fields in this configuration."),
+            providers = [SGXEnclaveConfigInfo],
+        ),
+        # "1" for release enclaves.
+        "disable_debug": attr.string(doc = _config_fields["disable_debug"]),
+        "heap_max_size": attr.string(doc = _config_fields["heap_max_size"]),
+        "isvsvn": attr.string(doc = _config_fields["isvsvn"]),
+        "misc_mask": attr.string(doc = _config_fields["misc_mask"]),
+        "misc_select": attr.string(doc = _config_fields["misc_select"]),
+        "prodid": attr.string(doc = _config_fields["prodid"]),
+        "provision_key": attr.string(doc = _config_fields["provision_key"]),
+        "kss": attr.bool(doc = _config_fields["kss"]),
+        "isvextprodid": attr.string(doc = _config_fields["isvextprodid"]),
+        "isvfamilyid": attr.string(doc = _config_fields["isvfamilyid"]),
+        "stack_max_size": attr.string(doc = _config_fields["stack_max_size"]),
+        "tcs_num": attr.string(doc = _config_fields["tcs_num"]),
+        "tcs_policy": attr.string(doc = _config_fields["tcs_policy"]),
+    },
+)
+
+def sgx_enclave_configuration(base = "@linux_sgx//:enclave_debug_config", **kwargs):
+    """Wraps sgx_full_enclave_configuration with a default base target.
+
+    Args:
+      base: An optional base config
+        [default @linux_sgx//:enclave_debug_config].
+      **kwargs: The rest of the sgx_full_enclave_configuration arguments.
+
+    Returns:
+      The result of invoking sgx_full_enclave_configuration rule.
+    """
+    sgx_full_enclave_configuration(base = base, **kwargs)
+
+def _sgx_sign_enclave_with_untrusted_key_impl(ctx):
+    """Implementation of an automated signing process of an unsigned enclave."""
+    unsigned = ctx.attr.unsigned
+    unsigned_file = ctx.file.unsigned
+    if type(unsigned) == "list":  # Split-n transitions use lists of targets.
+        # There is only one transition, no n-way split, but still the one is at
+        # the 0th index of the attribute.
+        unsigned = unsigned[0]
+    ctx.actions.run_shell(
+        inputs = [
+            unsigned_file,
+            ctx.file.key,
+            ctx.file.config,
+        ],
+        tools = [ctx.executable.sign_tool],
+        outputs = [ctx.outputs.executable],
+        progress_message = "Signing for debug: //{pkg}:{name}".format(
+            pkg = unsigned.label.package,
+            name = unsigned.label.name,
+        ),
+        # Suppresses tool output on success.
+        command = "output=`%s $@ 2>&1` || echo $output" %
+                  ctx.executable.sign_tool.path,
+        arguments = [
+            "sign",
+            "-enclave",
+            unsigned_file.path,
+            "-key",
+            ctx.file.key.path,
+            "-config",
+            ctx.file.config.path,
+            "-out",
+            ctx.outputs.executable.path,
+        ],
+    )
+    return [
+        DefaultInfo(files = depset([ctx.outputs.executable])),
+        backend_tools.EnclaveInfo(),
+        SGXEnclaveInfo(),
+    ]
+
+# The description for a config field, as shared by different rules.
+config_docstring = ("A path to a configuration XML file, or a label of " +
+                    "an sgx_enclave_config target. A configuration specifies " +
+                    "identity attributes, runtime behaviors that are " +
+                    "security-critical, and other components of the enclave " +
+                    "SIGSTRUCT.")
+
+# Skylark rule for the above implementation. Gives default debug arguments for
+# private attributes for signing tool, signing key, and signing configuration.
+def _make_sgx_sign_enclave_with_untrusted_key_rule(transition):
+    attrs = {
+        "config": attr.label(
+            default = None if transition else Label("@linux_sgx//:enclave_debug_config"),
+            mandatory = transition,
+            doc = config_docstring,
+            allow_single_file = True,
+            providers = [SGXEnclaveConfigInfo],
+        ),
+        "unsigned": attr.label(
+            cfg = transitions.backend if transition else None,
+            allow_single_file = True,
+            doc = "The label of the unsigned enclave to sign.",
+            providers = [SGXEnclaveInfo],
+        ),
+        "key": attr.label(
+            default = Label(
+                "@linux_sgx//:enclave_test_private.pem",
+            ),
+            allow_single_file = True,
+        ),
+        "sign_tool": attr.label(
+            default = None if transition else Label("@linux_sgx//:sgx_sign_tool"),
+            mandatory = transition,
+            allow_single_file = True,
+            executable = True,
+            cfg = "exec",
+        ),
+    }
+    return rule(
+        implementation = _sgx_sign_enclave_with_untrusted_key_impl,
+        executable = True,
+        doc = "Creates a signed enclave binary by using a debug key.",
+        attrs = backend_tools.merge_dicts(attrs, _transition_dict if transition else {}),
+    )
+
+_sgx_sign_enclave_with_untrusted_key = _make_sgx_sign_enclave_with_untrusted_key_rule(transition = False)
+
+
+def _placeholder(**kwargs):
+    fail("Transition support not implemented")
+
+_sgx_sign_enclave_with_untrusted_key_transition = _placeholder
+
+def _backend_sgx_sign_enclave_with_untrusted_key(name, backend_label_struct, **kwargs):
+    _sgx_sign_enclave_with_untrusted_key_transition(
+        name = name,
+        key = kwargs.pop("key", None) or backend_label_struct.debug_private_key,
+        config = kwargs.pop("config", None) or backend_label_struct.debug_default_config,
+        sign_tool = backend_label_struct.sign_tool,
+        **kwargs
+    )
+
+def sgx_sign_enclave_with_untrusted_key(
+        name,
+        unsigned,
+        config = None,
+        key = None,
+        tags = [],
+        backends = SGX_BACKEND_LABELS,
+        name_by_backend = {},
+        deprecation = None,
+        visibility = None,
+        testonly = False):
+    """Creates a signed enclave binary by using a debug key.
+
+    Args:
+        name: The target name
+        unsigned: The label of the unsigned enclave binary.
+        config: The enclave configuration label to use.
+        key: The untrusted key to use for signing.
+        tags: Bazel tags to add to name.
+        backends: The list of backends to build against.
+        name_by_backend: A dictionary from backend label to target name for
+            user-specified target names when defining backend-specific targets.
+        deprecation: An optional deprecation message that issues a warning.
+        visibility: The optional visibility of the enclave binary.
+        testonly: True if the target should only be used in tests.
+    """
+    kwargs = {
+        "config": config,
+        "unsigned": unsigned,
+        "key": key,
+        "tags": tags,
+        "deprecation": deprecation,
+        "visibility": visibility,
+        "testonly": testonly,
+    }
+    if transitions.supported(native.package_name()):
+        backend_tools.all_backends(
+            rule_or_macro = _backend_sgx_sign_enclave_with_untrusted_key,
+            name = name,
+            name_by_backend = name_by_backend,
+            backends = backends,
+            include_info = True,
+            kwargs = kwargs,
+        )
+    else:
+        kwargs["tags"] = kwargs.get("tags", []) + sgx_tags()
+        _sgx_sign_enclave_with_untrusted_key(name = name, **kwargs)
+
+def sgx_debug_enclave(name, **kwargs):
+    """An alias for sgx_sign_enclave_with_untrusted_key.
+
+    Args:
+        name: The name of the rule.
+        **kwargs: The rest of the arguments to
+            sgx_sign_enclave_with_untrusted_key.
+    """
+    sgx_sign_enclave_with_untrusted_key(name = name, **kwargs)
+
+def _sgx_generate_enclave_signing_material_impl(ctx):
+    """Implementation of the sign_tool's gendata command for sigstructs."""
+    signing_material = ctx.outputs.signing_material
+    if not signing_material:
+        signing_material = ctx.actions.declare_file(ctx.label.name + ".dat")
+    ctx.actions.run_shell(
+        inputs = [
+            ctx.file.unsigned,
+            ctx.file.config,
+        ],
+        tools = [ctx.executable.sign_tool],
+        outputs = [signing_material],
+        progress_message = "Generating enclave signing material for: //{pkg}:{name}".format(
+            pkg = ctx.attr.unsigned.label.package,
+            name = ctx.attr.unsigned.label.name,
+        ),
+        command = "output=`%s $@ 2>&1` || echo $output" %
+                  ctx.executable.sign_tool.path,
+        arguments = [
+            "gendata",
+            "-enclave",
+            ctx.file.unsigned.path,
+            "-config",
+            ctx.file.config.path,
+            "-out",
+            signing_material.path,
+        ],
+    )
+    return [
+        DefaultInfo(files = depset([signing_material])),
+        SGXSigstructInfo(
+            config = ctx.file.config,
+            unsigned = ctx.attr.unsigned,
+        ),
+    ]
+
+def _make_backend_sgx_generate_enclave_signing_material_rule(transition):
+    attrs = {
+        "config": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            providers = [SGXEnclaveConfigInfo],
+            doc = config_docstring,
+        ),
+        "unsigned": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            providers = [SGXEnclaveInfo],
+            doc = ("The label of the unsigned enclave binary to be measured " +
+                   "and hashed as a SIGSTRUCT field"),
+        ),
+        "signing_material": attr.output(
+            doc = "The name of the output file. Default is \"<name>.dat\".",
+        ),
+        "sign_tool": attr.label(
+            default = None if transition else Label("@linux_sgx//:sgx_sign_tool"),
+            mandatory = transition,
+            allow_single_file = True,
+            executable = True,
+            cfg = "exec",
+        ),
+    }
+    if transition:
+        attrs["backend"] = attr.label(
+            mandatory = True,
+            providers = [backend_tools.AsyloBackendInfo],
+        )
+        attrs["_whitelist_function_transition"] = attr.label(
+            default = Label("//tools/whitelists/function_transition_whitelist"),
+        )
+    return rule(
+        implementation = _sgx_generate_enclave_signing_material_impl,
+        doc = ("Creates a file that contains the parts of the enclave SIGSTRUCT" +
+               " that must be signed."),
+        cfg = transitions.backend if transition else None,
+        attrs = backend_tools.merge_dicts(attrs, _transition_dict if transition else {}),
+    )
+
+_sgx_generate_enclave_signing_material = _make_backend_sgx_generate_enclave_signing_material_rule(
+    transition = False,
+)
+
+_sgx_generate_enclave_signing_material_transition = _placeholder
+
+def _backend_sgx_generate_enclave_signing_material(
+        name,
+        backend,
+        backend_label_struct,
+        **kwargs):
+    _sgx_generate_enclave_signing_material_transition(
+        name = name,
+        backend = backend,
+        tags = kwargs.pop("tags", []) + backend_label_struct.tags,
+        sign_tool = backend_label_struct.sign_tool,
+        **kwargs
+    )
+
+def sgx_generate_enclave_signing_material(
+        name,
+        config,
+        unsigned,
+        backends = SGX_BACKEND_LABELS,
+        name_by_backend = {},
+        signing_material = None,
+        visibility = None,
+        tags = [],
+        testonly = 0):
+    """Builds the file to sign for creating a signed enclave binary.
+
+    Args:
+        name: The rule name, used in name derivations when transitions enabled.
+        backends: The list of backends to build against.
+        name_by_backend: A dictionary from backend label to target name for
+            user-specified target names when defining backend-specific targets.
+        config: An enclave_configuration target label.
+        unsigned: A label to an SGX unsigned enclave target. Should be generic
+            in the backends provided, so it is recommended to use an
+            sgx_cc_unsigned_enclave target.
+        signing_material: An optional output file name.
+        visibility: An optional visibility specification.
+        tags: Tags to apply to each target.
+        testonly: If true, the target may only be dependended on by testonly
+            and test targets.
+    """
+    kwargs = {
+        "config": config,
+        "unsigned": unsigned,
+        "signing_material": signing_material,
+        "visibility": visibility,
+        "testonly": testonly,
+        "tags": tags,
+    }
+    if transitions.supported(native.package_name()):
+        backend_tools.all_backends(
+            rule_or_macro = _backend_sgx_generate_enclave_signing_material,
+            name = name,
+            backends = backends,
+            name_by_backend = name_by_backend,
+            kwargs = kwargs,
+            include_info = True,
+        )
+    else:
+        _sgx_generate_enclave_signing_material(name = name, **kwargs)
+
+def sgx_generate_sigstruct(name, sigstruct = None, **kwargs):
+    """Creates a file that contains parts of the enclave SIGSTRUCT.
+
+    Args:
+        name: The rule name.
+        sigstruct: The name of the output file. Default is "<name>.dat".
+        **kwargs: The arguments passed to sgx_generate_enclave_signing_material.
+    """
+    sgx_generate_enclave_signing_material(
+        name = name,
+        deprecation = ("Please use sgx_generate_enclave_signing_material " +
+                       "because this macro may be removed or change meaning " +
+                       "in the future."),
+        signing_material = sigstruct,
+        **kwargs
+    )
+
+def _sign_signing_material_impl(ctx):
+    signature = ctx.attr.signature or ctx.actions.declare_file(ctx.label.name + ".sig")
+    ctx.actions.run_shell(
+        outputs = [signature],
+        inputs = [ctx.file.private_key, ctx.file.signing_material],
+        tools = [ctx.executable._bssl],
+        command = "{bssl} {args} < {signing_material} > {signature}".format(
+            bssl = ctx.file._bssl.path,
+            args = " ".join(["sign", "-digest", "sha256", "-key", ctx.file.private_key.path]),
+            signing_material = ctx.file.signing_material.path,
+            signature = signature.path,
+        ),
+    )
+    return [DefaultInfo(files = depset([signature]))]
+
+def _make_boringssl_sign_enclave_signing_material_rule(transition):
+    attrs = {
+        "signing_material": attr.label(
+            cfg = transitions.backend if transition else None,
+            mandatory = True,
+            allow_single_file = True,
+            providers = [SGXSigstructInfo],
+            doc = "A target defined by sgx_generate_enclave_signing_material.",
+        ),
+        "private_key": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            doc = ("The RSA-3072 private key with public exponent 3 in PEM " +
+                   "format used to sign the input enclave signing material."),
+        ),
+        "signature": attr.output(
+            doc = "The output signature file name [default: <name>.sig].",
+        ),
+        "_bssl": attr.label(
+            default = "//third_party/openssl:bssl",
+            allow_single_file = True,
+            executable = True,
+            cfg = "exec",
+        ),
+    }
+    return rule(
+        implementation = _sign_signing_material_impl,
+        doc = ("Signs an enclave signing material file with a given private " +
+               "key for use in sgx_signed_enclave."),
+        attrs = backend_tools.merge_dicts(
+            attrs,
+            _transition_dict if transition else {},
+        ),
+    )
+
+_boringssl_sign_enclave_signing_material = _make_boringssl_sign_enclave_signing_material_rule(
+    transition = False,
+)
+
+_boringssl_sign_enclave_signing_material_transition = _placeholder
+
+def boringssl_sign_enclave_signing_material(
+        name,
+        signing_material,
+        private_key,
+        signature = None,
+        backends = SGX_BACKEND_LABELS,
+        name_by_backend = {},
+        visibility = None,
+        tags = [],
+        testonly = 0):
+    """Signs signing material with a private key.
+
+    Signing is done in each backend if transitions enabled.
+
+    Args:
+        name: The rule name, used in name derivations if transitions enabled.
+        signing_material: The output of generate_enclave_signing_material.
+        private_key: A label to an RSA 3072 public exponent 3 private key in
+            PEM format.
+        signature: An optional output file name (default name + ".sig", where
+            name is backend-specific if transitions enabled).
+        backends: The list of backend labels to build signing_material against.
+        name_by_backend: An optional dictionary from backend label to name to
+            backend-specific target name.
+        visibility: An optional target visibility.
+        tags: Tags to apply to each target.
+        testonly: True if the target should only be used in tests.
+    """
+    kwargs = {
+        "signing_material": signing_material,
+        "private_key": private_key,
+        "signature": signature,
+        "visibility": visibility,
+        "testonly": testonly,
+        "tags": tags,
+    }
+    if transitions.supported(native.package_name()):
+        backend_tools.all_backends(
+            rule_or_macro = _boringssl_sign_enclave_signing_material_transition,
+            name = name,
+            name_by_backend = name_by_backend,
+            backends = backends,
+            kwargs = kwargs,
+        )
+    else:
+        _boringssl_sign_enclave_signing_material(name = name, **kwargs)
+
+def boringssl_sign_sigstruct(name, sigstruct, **kwargs):
+    """Signs enclave signing material with a given private key.
+
+    Args:
+        name: The rule name.
+        sigstruct: A target defined by sgx_generate_enclave_signing_material.
+        **kwargs: The arguments passed to boringssl_sign_enclave_signing_material.
+    """
+    boringssl_sign_enclave_signing_material(
+        name = name,
+        signing_material = sigstruct,
+        deprecation = ("Please use boringssl_sign_enclave_signing_material " +
+                       "as boringssl_sign_sigstruct is deprecated and will " +
+                       "be removed in the future."),
+        **kwargs
+    )
+
+def _sgx_signed_enclave_impl_helper(ctx, transition):
+    """Implementation of incorporating a signature into an enclave binary."""
+    signing_material = ctx.attr.signing_material[0] if transition else ctx.attr.signing_material
+    config = signing_material[SGXSigstructInfo].config
+    unsigned = signing_material[SGXSigstructInfo].unsigned
+    if SGXEnclaveInfo not in unsigned:
+        fail("Unsigned enclave referenced in config does not have SGXEnclaveInfo provider")
+    unsigned_file = unsigned.files.to_list()[0]
+    ctx.actions.run_shell(
+        inputs = [
+            config,
+            ctx.file.public_key,
+            ctx.file.signature,
+            ctx.file.signing_material,
+            unsigned_file,
+        ],
+        tools = [ctx.executable.sign_tool],
+        outputs = [ctx.outputs.executable],
+        progress_message = "Integrating signature into: //{pkg}:{name}".format(
+            pkg = unsigned.label.package,
+            name = unsigned.label.name,
+        ),
+        command = "output=`%s $@ 2>&1` || echo $output" %
+                  ctx.executable.sign_tool.path,
+        arguments = [
+            "catsig",
+            "-enclave",
+            unsigned_file.path,
+            "-key",
+            ctx.file.public_key.path,
+            "-sig",
+            ctx.file.signature.path,
+            "-config",
+            config.path,
+            "-unsigned",
+            ctx.file.signing_material.path,
+            "-out",
+            ctx.outputs.executable.path,
+        ],
+    )
+    return [
+        DefaultInfo(files = depset([ctx.outputs.executable])),
+        backend_tools.EnclaveInfo(),
+        SGXEnclaveInfo(),
+    ]
+
+def _sgx_signed_enclave_impl(ctx):
+    """Implementation of incorporating a signature into an enclave binary."""
+    return _sgx_signed_enclave_impl_helper(ctx, False)
+
+def _sgx_signed_enclave_transition_impl(ctx):
+    """Implementation of incorporating a signature into an enclave binary."""
+    return _sgx_signed_enclave_impl_helper(ctx, True)
+
+# Skylark rule for the above implementation.
+def _make_sgx_signing_rule(transition):
+    attrs = {
+        "public_key": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            doc = "The public key to verify the provided signature.",
+        ),
+        "signature": attr.label(
+            mandatory = True,
+            allow_single_file = True,
+            doc = "The sha256 digest of the enclave signing material signed " +
+                  "by the RSA-3072 private key with public exponent 3.",
+        ),
+        "signing_material": attr.label(
+            cfg = transitions.backend if transition else None,
+            mandatory = True,
+            allow_single_file = True,
+            providers = [SGXSigstructInfo],
+            doc = ("The label of a sgx_generate_enclave_signing_material target that " +
+                   "includes both the unsigned enclave and its config."),
+        ),
+        "sign_tool": attr.label(
+            default = None if transition else Label("@linux_sgx//:sgx_sign_tool"),
+            mandatory = transition,
+            allow_single_file = True,
+            executable = True,
+            cfg = "exec",
+        ),
+    }
+    return rule(
+        implementation = _sgx_signed_enclave_transition_impl if transition else _sgx_signed_enclave_impl,
+        executable = True,
+        doc = "Creates a signed enclave binary using a signature file.",
+        attrs = backend_tools.merge_dicts(attrs, _transition_dict if transition else {}),
+    )
+
+_sgx_signed_enclave = _make_sgx_signing_rule(transition = False)
+
+_sgx_signed_enclave_transition = _placeholder
+
+def _backend_sgx_signed_enclave(name, backend_label_struct, **kwargs):
+    _sgx_signed_enclave_transition(
+        name = name,
+        sign_tool = backend_label_struct.sign_tool,
+        tags = kwargs.pop("tags", []) + backend_label_struct.tags,
+        **kwargs
+    )
+
+def sgx_signed_enclave(
+        name,
+        public_key,
+        signature,
+        signing_material,
+        backends = SGX_BACKEND_LABELS,
+        name_by_backend = {},
+        visibility = None,
+        testonly = 0,
+        tags = []):
+    """Creates a signed enclave binary using a signature file.
+
+    Args:
+        name: The rule name, used in name derivations when transitions enabled.
+        public_key: The public key to verify the provided signature.
+        signature: The sha256 digest of the enclave signing material signed by
+            the RSA-3072 private key with public exponent 3.
+        signing_material: The label of a sgx_generate_enclave_signing_material
+            target that includes both the unsigned enclave and its config.
+        backends: The list of backends to build against.
+        name_by_backend: A dictionary from backend label to target name for
+            user-specified target names when defining backend-specific targets.
+        visibility: An optional visibility specification.
+        testonly: If true, the target may only be dependended on by testonly
+            and test targets.
+        tags: Tags to apply to each target.
+    """
+    kwargs = {
+        "public_key": public_key,
+        "signature": signature,
+        "signing_material": signing_material,
+        "visibility": visibility,
+        "testonly": testonly,
+        "tags": tags,
+    }
+    if transitions.supported(native.package_name()):
+        backend_tools.all_backends(
+            rule_or_macro = _backend_sgx_signed_enclave,
+            name = name,
+            backends = backends,
+            name_by_backend = name_by_backend,
+            include_info = True,
+            kwargs = kwargs,
+        )
+    else:
+        _sgx_signed_enclave(name = name, **kwargs)
+
+
+def sgx_tags():
+    """Returns tags for SGX targets."""
+    return [
+        "manual",
+        "sgxbuilder",
+    ]
+
+def _extend_enclave_name(enclave, str):
+    """Injects 'str' before '.so' if '.so' in enclave, otherwise appends 'str.so'.
+
+    Args:
+      enclave: Input string
+      str: String to append.
+
+    Returns:
+      string: Name of enclave with str appended.
+    """
+    if ".so" not in enclave:
+        return enclave + str + ".so"
+    else:
+        return enclave.replace(".so", str + ".so", 1)
+
+def _unsigned_enclave_name(enclave):
+    return _extend_enclave_name(enclave, "_unsigned")
+
+def _asylo_sgx_backend_impl(ctx):
+    return [backend_tools.AsyloBackendInfo(
+        forward_providers = [backend_tools.EnclaveInfo, SGXEnclaveInfo, SGXSigstructInfo, SGXEnclaveConfigInfo, CcInfo],
+        unsigned_enclave_implementation = _sgx_cc_unsigned_enclave_impl,
+        untrusted_sign_implementation = _sgx_sign_enclave_with_untrusted_key_impl,
+    )]
+
+asylo_sgx_backend = rule(
+    doc = ("Defines an Asylo backend label for the SGX backend. Should only " +
+           "be used by @linux_sgx."),
+    implementation = _asylo_sgx_backend_impl,
+    attrs = {},
+)
+
+# Export all rules and macros in one identifier to load.
+sgx = struct(
+    backend_labels = SGX_BACKEND_LABELS,
+    boringssl_sign_sigstruct = boringssl_sign_sigstruct,
+    boringssl_sign_enclave_signing_material = boringssl_sign_enclave_signing_material,
+    debug_enclave = sgx_debug_enclave,
+    sign_enclave_with_untrusted_key = sgx_sign_enclave_with_untrusted_key,
+    enclave_configuration = sgx_enclave_configuration,
+    full_enclave_configuration = sgx_full_enclave_configuration,
+    generate_enclave_signing_material = sgx_generate_enclave_signing_material,
+    generate_sigstruct = sgx_generate_sigstruct,
+    signed_enclave = sgx_signed_enclave,
+    tags = sgx_tags,
+    unsigned_enclave = sgx_unsigned_enclave,
+)
diff -Nur /dev/null internal.bzl
--- /dev/null
+++ internal.bzl
@@ -0,0 +1,26 @@
+"""Build rules and settings internal to the linux_sgx library."""
+
+load("@com_google_asylo_backend_provider//:transitions.bzl", "transitions")
+
+_internal_simulation_label = "@linux_sgx//:internal_is_simulation"
+
+_sgx_is_simulation = provider(fields = {
+    "simulation": ("Boolean for internal selection of simulation or " +
+                   "hardware backends."),
+})
+
+def _is_simulation_impl(ctx):
+    return [_sgx_is_simulation(simulation = ctx.build_setting_value)]
+
+internal_is_simulation = rule(
+    doc = ("Defines a build setting for whether the internal backend is set," +
+           " and if it is set to simulation or hardware (0, 1, 2 " +
+           "respectively)"),
+    implementation = _is_simulation_impl,
+    build_setting = config.int(),
+)
+
+def _internal_simulation_transition_impl(settings, attrs):
+    _ignore = (settings, attrs)
+    return {_internal_simulation_label: 1 if attrs.simulation else 2}
+
diff -Nur /dev/null debug_key_mrsigner.cc
--- /dev/null
+++ debug_key_mrsigner.cc
@@ -0,0 +1,18 @@
+#include "debug_key_mrsigner.h"
+
+namespace linux_sgx {
+
+// To generate this constant from enclave_test_private.pem, run the following
+// command:
+// openssl rsa -in enclave_test_private.pem -modulus -noout
+// | sed -e 's/Modulus=//' | xxd -r -p -
+// | perl -077e 'print scalar reverse <>'
+// | sha256sum
+const char *const kDebugKeyMrsignerHex =
+    "83d719e77deaca1470f6baf62a4d774303c899db69020f9c70ee1dfc08c7ce9e";
+
+const char *const kDebugKeyMrsignerTextProto = R"pb(
+  hash: "\x83\xd7\x19\xe7\x7d\xea\xca\x14\x70\xf6\xba\xf6\x2a\x4d\x77\x43\x03\xc8\x99\xdb\x69\x02\x0f\x9c\x70\xee\x1d\xfc\x08\xc7\xce\x9e"
+)pb";
+
+}  // namespace linux_sgx
diff -Nur /dev/null debug_key_mrsigner.h
--- /dev/null
+++ debug_key_mrsigner.h
@@ -0,0 +1,14 @@
+#ifndef _DEBUG_KEY_MRSIGNER_H_
+#define _DEBUG_KEY_MRSIGNER_H_
+
+namespace linux_sgx {
+
+// Hex-encoded constant representing the MRSIGNER value for enclaves signed
+// using the debug signing key.
+extern const char *const kDebugKeyMrsignerHex;
+
+extern const char *const kDebugKeyMrsignerTextProto;
+
+}  // namespace linux_sgx
+
+#endif  // _DEBUG_KEY_MRSIGNER_H_
diff -Nur /dev/null enclave.lds.tpl
--- /dev/null
+++ enclave.lds.tpl
@@ -0,0 +1,10 @@
+enclave.so
+{
+    global:
+        enclave_entry;
+        g_global_data;
+        {g_global_data_sim}
+        {g_peak_heap_used}
+    local:
+        *;
+};
diff -Nur /dev/null include/global_data.h
--- /dev/null
+++ include/global_data.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_GLOBAL_DATA_H_
+#define _INCLUDE_GLOBAL_DATA_H_
+
+#include "common/inc/internal/global_data.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_GLOBAL_DATA_H_
diff -Nur /dev/null include/se_memcpy.h
--- /dev/null
+++ include/se_memcpy.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SE_MEMCPY_H_
+#define _INCLUDE_SE_MEMCPY_H_
+
+#include "common/inc/internal/se_memcpy.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SE_MEMCPY_H_
diff -Nur /dev/null include/sgx.h
--- /dev/null
+++ include/sgx.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_H_
+#define _INCLUDE_SGX_H_
+
+#include "common/inc/sgx.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_H_
diff -Nur /dev/null include/sgx_cpuid.h
--- /dev/null
+++ include/sgx_cpuid.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_INCLUDE_SGX_CPUID_H_
+#define _INCLUDE_INCLUDE_SGX_CPUID_H_
+
+#include "common/inc/sgx_cpuid.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_INCLUDE_SGX_CPUID_H_
diff -Nur /dev/null include/sgx_edger8r.h
--- /dev/null
+++ include/sgx_edger8r.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_EDGER8R_H_
+#define _INCLUDE_SGX_EDGER8R_H_
+
+#include "common/inc/sgx_edger8r.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_EDGER8R_H_
diff -Nur /dev/null include/sgx_eid.h
--- /dev/null
+++ include/sgx_eid.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_EID_H_
+#define _INCLUDE_SGX_EID_H_
+
+#include "common/inc/sgx_eid.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_EID_H_
diff -Nur /dev/null include/sgx_error.h
--- /dev/null
+++ include/sgx_error.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_ERROR_H_
+#define _INCLUDE_SGX_ERROR_H_
+
+#include "common/inc/sgx_error.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_ERROR_H_
diff -Nur /dev/null include/sgx_key.h
--- /dev/null
+++ include/sgx_key.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_KEY_H_
+#define _INCLUDE_SGX_KEY_H_
+
+#include "common/inc/sgx_key.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_KEY_H_
diff -Nur /dev/null include/sgx_lfence.h
--- /dev/null
+++ include/sgx_lfence.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_LFENCE_H_
+#define _INCLUDE_SGX_LFENCE_H_
+
+#include "common/inc/sgx_lfence.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_LFENCE_H_
diff -Nur /dev/null include/sgx_quote.h
--- /dev/null
+++ include/sgx_quote.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_QUOTE_H_
+#define _INCLUDE_SGX_QUOTE_H_
+
+#include "common/inc/sgx_quote.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_QUOTE_H_
diff -Nur /dev/null include/sgx_report.h
--- /dev/null
+++ include/sgx_report.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_REPORT_H_
+#define _INCLUDE_SGX_REPORT_H_
+
+#include "common/inc/sgx_report.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_REPORT_H_
diff -Nur /dev/null include/sgx_thread.h
--- /dev/null
+++ include/sgx_thread.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_THREAD_H_
+#define _INCLUDE_SGX_THREAD_H_
+
+#include "common/inc/sgx_thread.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_THREAD_H_
diff -Nur /dev/null include/sgx_trts.h
--- /dev/null
+++ include/sgx_trts.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TRTS_H_
+#define _INCLUDE_SGX_TRTS_H_
+
+#include "common/inc/sgx_trts.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TRTS_H_
diff -Nur /dev/null include/sgx_trts_exception.h
--- /dev/null
+++ include/sgx_trts_exception.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TRTS_EXCEPTION_H_
+#define _INCLUDE_SGX_TRTS_EXCEPTION_H_
+
+#include "common/inc/sgx_trts_exception.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TRTS_EXCEPTION_H_
diff -Nur /dev/null include/sgx_tseal.h
--- /dev/null
+++ include/sgx_tseal.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_TSEAL_H_
+#define _INCLUDE_SGX_TSEAL_H_
+
+#include "common/inc/sgx_tseal.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_TSEAL_H_
diff -Nur /dev/null include/sgx_uae_service.h
--- /dev/null
+++ include/sgx_uae_service.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_UAE_SERVICE_H_
+#define _INCLUDE_SGX_UAE_SERVICE_H_
+
+#include "common/inc/sgx_uae_service.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_UAE_SERVICE_H_
diff -Nur /dev/null include/sgx_urts.h
--- /dev/null
+++ include/sgx_urts.h
@@ -0,0 +1,6 @@
+#ifndef _INCLUDE_SGX_URTS_H_
+#define _INCLUDE_SGX_URTS_H_
+
+#include "common/inc/sgx_urts.h"  // IWYU pragma: export
+
+#endif  // _INCLUDE_SGX_URTS_H_
diff -Nur /dev/null runtime_support/rts_config.h
--- /dev/null
+++ runtime_support/rts_config.h
@@ -0,0 +1,23 @@
+#ifndef _RUNTIME_SUPPORT_RTS_CONFIG_H_
+#define _RUNTIME_SUPPORT_RTS_CONFIG_H_
+
+#include <string.h>
+
+#ifndef _ERNNO_T_DEFINED
+#define _ERRNO_T_DEFINED
+typedef int errno_t;
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+errno_t memset_s(void *s, size_t smax, int c, size_t n);
+
+int consttime_memequal(const void *b1, const void *b2, size_t len);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // _RUNTIME_SUPPORT_RTS_CONFIG_H_
diff -Nur /dev/null runtime_support/sgx_init_crypto_lib.c
--- /dev/null
+++ runtime_support/sgx_init_crypto_lib.c
@@ -0,0 +1,10 @@
+
+#include <stdint.h>
+
+#include "sgx_error.h"
+
+sgx_status_t sgx_init_crypto_lib(uint64_t cpu_feature_indicator,
+                                 uint32_t *cpuid_table) {
+  return SGX_SUCCESS;
+}
+
diff -Nur /dev/null runtime_support/sgx_init_string_lib.c
--- /dev/null
+++ runtime_support/sgx_init_string_lib.c
@@ -0,0 +1,8 @@
+
+#include <stdint.h>
+
+int __NR_rt_sigprocmask;
+
+int sgx_init_string_lib(uint64_t cpu_feature_indicator) {
+  return 0;
+}
diff -Nur /dev/null external/rdrand/src/config.h
--- /dev/null
+++ external/rdrand/src/config.h
@@ -0,0 +1,53 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "Intel Software Network"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "librdrand"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "librdrand 1.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "librdrand"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.1"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if using gcc and it supports RDRAND */
+#define HAVE_RDRAND_IN_GCC 1
